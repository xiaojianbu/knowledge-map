# 插入排序

把要排序的数组分为了两个部分, 一部分是数组的全部元素(除去待插入的元素), 另一部分是待插入的元素; 先将第一部分排序完成, 然后再插入这个元素. 其中第一部分的排序也是通过再次拆分为两部分来进行的.

```js
function directInsertionSort(array) {
  var length = array.length,
    index,
    current
  for (var i = 1; i < length; i++) {
    index = i - 1 //待比较元素的下标
    current = array[i] //当前元素
    while (index >= 0 && array[index] > current) {
      //前置条件之一:待比较元素比当前元素大
      array[index + 1] = array[index] //将待比较元素后移一位
      index-- //游标前移一位
      //console.log(array);
    }
    if (index + 1 != i) {
      //避免同一个元素赋值给自身
      array[index + 1] = current //将当前元素插入预留空位
      //console.log(array);
    }
  }
  return array
}
```

## 折半插入排序

算法基本思想是:

1. 取 0 ~ i-1 的中间点( m = (i-1)>>1 ), array[i] 与 array[m] 进行比较, 若 array[i] < array[m] , 则说明待插入的元素 array[i] 应该处于数组的 0 ~ m 索引之间; 反之, 则说明它应该处于数组的 m ~ i-1 索引之间.
2. 重复步骤 1, 每次缩小一半的查找范围, 直至找到插入的位置.
3. 将数组中插入位置之后的元素全部后移一位.
4. 在指定位置插入第 i 个元素.

```js
function binaryInsertionSort(array) {
  var current, i, j, low, high, m
  for (i = 1; i < array.length; i++) {
    low = 0
    high = i - 1
    current = array[i]

    while (low <= high) {
      //步骤1&2:折半查找
      m = (low + high) >> 1
      if (array[i] >= array[m]) {
        //值相同时, 切换到高半区，保证稳定性
        low = m + 1 //插入点在高半区
      } else {
        high = m - 1 //插入点在低半区
      }
    }
    for (j = i; j > low; j--) {
      //步骤3:插入位置之后的元素全部后移一位
      array[j] = array[j - 1]
    }
    array[low] = current //步骤4:插入该元素
  }
  return array
}
```

## 希尔排序

算法的基本思想:

1. 将数组拆分为若干个子分组, 每个分组由相距一定"增量"的元素组成. 比方说将[0,1,2,3,4,5,6,7,8,9,10]的数组拆分为"增量"为 5 的分组, 那么子分组分别为 [0,5], [1,6], [2,7], [3,8], [4,9] 和 [5,10].
2. 然后对每个子分组应用直接插入排序.
3. 逐步减小"增量", 重复步骤 1,2.
4. 直至"增量"为 1, 这是最后一个排序, 此时的排序, 也就是对全数组进行直接插入排序.

```js
//形参增加步数gap(实际上就相当于gap替换了原来的数字1)
function directInsertionSort(array, gap) {
  gap = gap == undefined ? 1 : gap //默认从下标为1的元素开始遍历
  var length = array.length,
    index,
    current
  for (var i = gap; i < length; i++) {
    index = i - gap //待比较元素的下标
    current = array[i] //当前元素
    while (index >= 0 && array[index] > current) {
      //前置条件之一:待比较元素比当前元素大
      array[index + gap] = array[index] //将待比较元素后移gap位
      index -= gap //游标前移gap位
    }
    if (index + gap != i) {
      //避免同一个元素赋值给自身
      array[index + gap] = current //将当前元素插入预留空位
    }
  }
  return array
}
function shellSort(array) {
  var length = array.length,
    gap = length >> 1,
    current,
    i,
    j
  while (gap > 0) {
    directInsertionSort(array, gap) //按指定步长进行直接插入排序
    gap = gap >> 1
  }
  return array
}
```
