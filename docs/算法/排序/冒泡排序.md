# 冒泡排序

冒泡排序需要两个嵌套的循环. 其中, 外层循环移动游标; 内层循环遍历游标及之后(或之前)的元素, 通过两两交换的方式, 每次只确保该内循环结束位置排序正确, 然后内层循环周期结束, 交由外层循环往后(或前)移动游标, 随即开始下一轮内层循环, 以此类推, 直至循环结束.

冒泡排序只在相邻元素大小不符合要求时才调换他们的位置, 它并不改变相同元素之间的相对顺序, 因此它是稳定的排序算法.

```js
//先将交换元素部分抽象出来
function swap(i, j, array) {
  var temp = array[j]
  array[j] = array[i]
  array[i] = temp
}
function bubbleSort(array) {
  var length = array.length,
    isSwap
  for (var i = 0; i < length; i++) {
    //正序
    isSwap = false
    for (var j = 0; j < length - 1 - i; j++) {
      //正序
      array[j] > array[j + 1] && (isSwap = true) && swap(j, j + 1, array)
    }
    if (!isSwap) break
  }
  return array
}
```

## 双向冒泡排序

双向冒泡排序顾名思义就是从两个方向分别排序(通常, 先从低到高, 然后从高到低).

```js
function bothwayBubbleSort(array) {
  var tail = array.length - 1,
    i,
    isSwap = false
  for (i = 0; i < tail; tail--) {
    for (var j = tail; j > i; j--) {
      //第一轮, 先将最小的数据冒泡到前面
      array[j - 1] > array[j] && (isSwap = true) && swap(j, j - 1, array)
    }
    i++
    for (j = i; j < tail; j++) {
      //第二轮, 将最大的数据冒泡到后面
      array[j] > array[j + 1] && (isSwap = true) && swap(j, j + 1, array)
    }
  }
  return array
}
```
