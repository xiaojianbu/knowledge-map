# 链表有关的算法

## 判断链表是否有环

1.  用两个指针 p1 和 p2 分别指向表头节点
2.  p1 和 p2 分别采用 1 和 2 作为步长遍历该链表
3.  若 p1 和 p2 遇到了 NULL,则证明该链表没有环，若 p1 和 p2 在某时刻指向同一节点，则说明该链表有环。

```js
function listLoop(head) {
  let fast = head
  let slow = head

  while (fast && fast.next) {
    fast = fast.next.next
    slow = slow.next
    if (fast === slow) {
      break
    }
  }

  return !(fast === null || fast.next === null)
}
```

4.  若该链表有环

    1.  设从表头结点（包括）开始到环开始的结点（不包括）共 有 l1 个结点；设从环开始结点（包括）到它们相遇的结点（不包括）共有 l2 个结点；设从他们第一次相遇的结点开始（包括）到环开始结点（不包括）共有 l3 个结点；设整个环共有 c 个结点。则有 c=l2+l3，且 l1+l2 即为它们第一次相遇时，p1 所遍历的结点个数。
    2.  当它们第一次相遇时，固定 p2，然后 p1 以 1 为步长继续遍历此表，则他们再次相遇时，p1 从上次相遇到这次相遇所经过的总步长即为环中结点的个数 c。
    3.  可以证明，当他们第一次相遇时，p1 不可能经过环开始结点两次，即不可能开始第二次遍历环。设当它们第一次相遇时，p2 已经把环遍历了 k 遍(k>=1)则有：2(l1+l2) = l1+l2+kc，即 l1+l2=kc
    4.  l1+l2=kc=>l1=(k-1)c+l3
    5.  固定 p2 在它们第一次相遇的结点，然后 p1 回到表头，然后它们均以 1 为步长遍历链表，则它们第一次相遇时，即为环开始结点
