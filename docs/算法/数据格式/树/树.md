# 树

## 二叉树

二叉树的遍历分为前序遍历、中序遍历和后序遍历

### 前序遍历

首先访问根节点，然后遍历左子树，最后遍历右子树

递归实现：

1.  若二叉树为空，则算法结束，否则：
2.  访问根节点；
3.  前序遍历根节点的左子树
4.  前序遍历根节点的右子树

```js
function preOrder(node, callback) {
  if (node !== null) {
    callback(node.key)
    preOrder(node.left, callback)
    preOrder(node.right, callback)
  }
}
```

非递归实现：

1.  初始化一个栈，将根节点压入栈中；
2.  当栈为非空时，循环执行步骤 3 到 4，否则执行结束；
3.  出队列取得一个结点，访问该结点；
4.  若该结点的右子树为非空，则将该结点的右子树入栈，若该结点的左子树为非空，则将该结点的左子树入栈。

```js
function preOrder(node, callback) {
  let stack = []
  stack.push(node)
  while (stack.length) {
    let item = stack.pop()
    callback(item)
    item.right && stack.push(item.right)
    item.left && stack.push(item.left)
  }
}
```

### 中序遍历

首先遍历左子树，然后访问根节点，最后遍历右子树

递归实现：

1.  若二叉树为空，则算法结束；否则：
2.  中序遍历根节点的左子树
3.  访问根节点
4.  中序遍历根节点的右子树

```js
function inOrder(node, callback) {
  if (node !== null) {
    inOrder(node.left)
    callback(node.key)
    inOrder(node.right)
  }
}
```

非递归实现：

1.  初始化一个栈，将根节点压入栈中，并标记为当前节点；
2.  当栈为非空时，执行步骤三，否则执行结束；
3.  如果当前节点有左子树且没有被 touched，则执行 4，否则执行 5；
4.  对当前节点标记标记 touched，将当前节点的左子树赋值给当前节点（item=item.left）并将当前节点压入栈中，回到 3；
5.  清理当前节点的 touched 标记，取出栈中的一个节点标记为当前节点，并访问，若当前节点的右子树为非空，则将该节点的右子树入栈，回到 3；

```js
function inOrder(node, callback) {
  let stack = []
  let item = node
  stack.push(node)
  while (stack.length) {
    if (item.left && !item.touched) {
      item.touched = true
      item = item.left
      stack.push(item)
      continue
    }
    item.touched && delete item.touched
    item = stack.pop()
    callback(item)
    item.right && stack.push(item.right)
  }
}
```

### 后序遍历

首先遍历左子树，然后遍历右子树，最后访问根节点

递归实现：

1.  若二叉树为空，则算法结束，否则：
2.  后序遍历根节点的左子树；
3.  后序遍历根节点的右子树；
4.  访问根节点。

```js
function postOrder(node, callback) {
  if (node !== null) {
    postOrder(node.left)
    postOrder(node.right)
    callback(node.key)
  }
}
```

非递归实现：

1.  初始化一个栈，将根节点压入栈中，并标记为当前节点；
2.  当栈为非空时，执行步骤 3，否则执行结束；
3.  如果当前节点有左子树且没有被 touched，则执行 4，如果被 touched left 但没有被 touched right 则执行 5 否则执行 6；
4.  对当前节点标记 touched left,将当前节点的左子树赋值给当前节点并将当前节点压入栈中，回到 3；
5.  对当前节点标记 touched right；将当前节点的右子树赋值给当前节点，并将当前节点压入栈中，回到 3；
6.  清理当前节点的 touched 标记，弹出栈中的一个节点并访问，然后再将栈顶节点标记为当前节点，回到 3.

```js
function postOrder(node, callback) {
  let stack = []
  let item = node
  stack.push(node)
  while (stack.length) {
    if (item.left && !item.touched) {
      item.touched = 'left'
      item = item.left
      stack.push(item)
      continue
    }
    if (item.right && item.touched !== 'right') {
      item.touched = 'right'
      item = item.right
      stack.push(item)
      continue
    }
    let out = stack.pop()
    out.touched && delete out.touched
    callback(out)
    item = stack.length ? stack[stack.length - 1] : null
  }
}
```

## 多叉树

多叉树的遍历分为广度遍历和深度遍历

### 广度遍历

首先访问根节点，然后访问第一层，第二层节点，直到访问到最后一层。

实现方法，借助队列

```js
function bfSearch(node, callback) {
  let queue = []
  while (node !== null) {
    callback(node)
    if (node.children.length !== 0) {
      for (let i = 0; i < node.children.length; i++) {
        queue.push(node.children[i])
      }
    }
    node = queue.shift()
  }
}
```

### 深度遍历

首先遍历根节点，然后沿着一个路径遍历到最深的一层，最后在逐层返回

借助栈

```js
function dfSearch(node, callback) {
  let stack = []
  while (node !== null) {
    callback(node)
    if (node.children.length !== 0) {
      for (let i = node.children.length - 1; i >= 0; i--) {
        stack.push(node.children[i])
      }
    }
    node = stack.pop()
  }
}
```
