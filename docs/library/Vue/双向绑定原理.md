# 双向绑定

1. 事件机制（pub/sub）：我们通过特定的方法修改数据，例如 Store.set('key', 'value')，set 方法修改数据的同时触发一个事件，告诉 view 数据发生了更改，view 立即从新从 store 拉取数据。这类似于 Flux 中 View 对于 Store 数据的响应，只不过通过某种方法或者 directive 将这种机制封装起来了。这种机制的弱势在于你没法用传统的方式等号=对数据进行赋值。
2. 轮询（pull/dirty check）：这个方式就更加简单了，数据的消费方不断的检测数据有没有修改。当然不是无时无刻的进行检测，而是在 input 事件或者 change 事件的时候进行检测。Angular 1.0 使用的就是这种机制。我个人倾向于把这种方式称为轮询而不是脏检查
3. Javascript 中，我们可以给对象中的值定义访问器 Object 天生的支持的属性访问器 defineProperty。那么接下来当你每次想访问 data 中 key 字段时，无论是取值 data.key 还是赋值 data.key = 'Hi'，都会有打印信息。这也意味着，我们能够在用户执行普通的赋值和取值操作时，做一些事情，例如通知数据的消费者数据发生了更改，让它们重新编译模板。这也就是 Vue.js 双向绑定的思路。当然这只是双向数据绑定的一个环节，但是是最核心的环节，其他还包括如何添加订阅者，如何编译模板

在初始化 data props 时，递归对象，给每一个属性双向绑定，对于数组而言，会拿到原型重写函数，实现手动派发更新。因为函数不能监听到数据的变动，和 proxy 比较一下。

除了以上数组函数，通过索引改变数组数据或者给对象添加新属性也不能触发，需要使用自带的 set 函数，这个函数内部也是手动派发更新

在组件挂载时，会实例化渲染观察者，传入组件更新的回调。在实例化过程中，会对模板中的值对象进行求值，触发依赖收集。在触发依赖之前，会保存当前的渲染观察者，用于组件含有子组件的时候，恢复父组件的观察者。触发依赖收集后，会清理掉不需要的依赖，性能优化，防止不需要的地方去重复渲染。

改变值会触发依赖更新，会将收集到的所有依赖全部拿出来，放入 nextTick 中统一执行。执行过程中，会先对观察者进行排序，渲染的最后执行。先执行 beforeupdate 钩子函数，然后执行观察者的回调。在执行回调的过程中，可能 watch 会再次 push 进来，因为存在在回调中再次赋值，判断无限循环。

vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过 Object.defineProperty()来劫持各个属性的 setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。

具体步骤：

第一步：需要 observe 的数据对象进行递归遍历，包括子属性对象的属性，都加上 setter 和 getter。这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化

第二步：compile 解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图

第三步：Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁，主要做的事情是:

1、在自身实例化时往属性订阅器(dep)里面添加自己

2、自身必须有一个 update()方法

3、待属性变动 dep.notice()通知时，能调用自身的 update()方法，并触发 Compile 中绑定的回调，则功成身退。

第四步：MVVM 作为数据绑定的入口，整合 Observer、Compile 和 Watcher 三者，通过 Observer 来监听自己的 model 数据变化，通过 Compile 来解析编译模板指令，最终利用 Watcher 搭起 Observer 和 Compile 之间的通信桥梁，达到数据变化 -> 视图更新；视图交互变化(input) -> 数据 model 变更的双向绑定效果。

实现数据监听器 Observer，用 Object.defineProperty()重写数据的 get、set，值更新就在 set 中通知订阅者更新数据。
实现模板编译 Compile，深度遍历 dom 树，对每个元素节点的指令模板进行替换数据以及订阅数据。
实现 Watch 用于连接 Observer 和 Compile，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数，从而更新视图。
mvvm 入口函数，整合以上三者。

```html
<!DOCTYPE html>
<head>
  <title>myVue</title>
</head>
<style>
  #app {
    text-align: center;
  }
</style>
<body>
  <div id="app">
    <form>
      <input type="text" v-model="number" />
      <button type="button" v-click="increment">增加</button>
    </form>
    <h3 v-bind="number"></h3>
    <form>
      <input type="text" v-model="count" />
      <button type="button" v-click="incre">增加</button>
    </form>
    <h3 v-bind="count"></h3>
  </div>
</body>

<script>
  function myVue(options) {
    this._init(options)
  }

  myVue.prototype._init = function(options) {
    this.$options = options
    this.$el = document.querySelector(options.el)
    this.$data = options.data
    this.$methods = options.methods

    this._binding = {}
    this._obverse(this.$data)
    this._complie(this.$el)
  }

  myVue.prototype._obverse = function(obj) {
    var _this = this
    Object.keys(obj).forEach(function(key) {
      if (obj.hasOwnProperty(key)) {
        _this._binding[key] = {
          _directives: []
        }
        console.log(_this._binding[key])
        var value = obj[key]
        if (typeof value === 'object') {
          _this._obverse(value)
        }
        var binding = _this._binding[key]
        Object.defineProperty(_this.$data, key, {
          enumerable: true,
          configurable: true,
          get: function() {
            console.log(`${key}获取${value}`)
            return value
          },
          set: function(newVal) {
            console.log(`${key}更新${newVal}`)
            if (value !== newVal) {
              value = newVal
              binding._directives.forEach(function(item) {
                item.update()
              })
            }
          }
        })
      }
    })
  }

  myVue.prototype._complie = function(root) {
    var _this = this
    var nodes = root.children
    for (var i = 0; i < nodes.length; i++) {
      var node = nodes[i]
      if (node.children.length) {
        this._complie(node)
      }

      if (node.hasAttribute('v-click')) {
        node.onclick = (function() {
          var attrVal = nodes[i].getAttribute('v-click')
          return _this.$methods[attrVal].bind(_this.$data)
        })()
      }

      if (
        node.hasAttribute('v-model') &&
        (node.tagName = 'INPUT' || node.tagName == 'TEXTAREA')
      ) {
        node.addEventListener(
          'input',
          (function(key) {
            var attrVal = node.getAttribute('v-model')
            _this._binding[attrVal]._directives.push(
              new Watcher('input', node, _this, attrVal, 'value')
            )

            return function() {
              _this.$data[attrVal] = nodes[key].value
            }
          })(i)
        )
      }

      if (node.hasAttribute('v-bind')) {
        var attrVal = node.getAttribute('v-bind')
        _this._binding[attrVal]._directives.push(
          new Watcher('text', node, _this, attrVal, 'innerHTML')
        )
      }
    }
  }

  function Watcher(name, el, vm, exp, attr) {
    this.name = name //指令名称，例如文本节点，该值设为"text"
    this.el = el //指令对应的DOM元素
    this.vm = vm //指令所属myVue实例
    this.exp = exp //指令对应的值，本例如"number"
    this.attr = attr //绑定的属性值，本例为"innerHTML"

    this.update()
  }

  Watcher.prototype.update = function() {
    this.el[this.attr] = this.vm.$data[this.exp]
  }

  window.onload = function() {
    var app = new myVue({
      el: '#app',
      data: {
        number: 0,
        count: 0
      },
      methods: {
        increment: function() {
          this.number++
        },
        incre: function() {
          this.count++
        }
      }
    })
  }
</script>
```

```html
<html>
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0"
    />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>proxyVue</title>
    <style>
      #app {
        margin: 100px auto 0 auto;
        width: 300px;
      }
      #btn {
        margin: 10px auto;
      }
    </style>
  </head>
  <body>
    <div id="app">
      <input type="text" v-model="num" />
      <input
        id="btn"
        type="button"
        value="添加到Todolist"
        v-click="addList"
      /><br />
      <span>您输入的是：</span><span v-bind="num"></span>
      <ul id="list"></ul>
    </div>
  </body>

  <script>
    class proxyVue {
      constructor(options) {
        this.$options = options || {}
        this.$methods = this._methods = this.$options.methods
        const data = (this._data = this.$options.data)
        this.subscribe = {}
        this.observe(data)
        this.compile(options.el)
      }
      publish(watcher) {
        if (!this.subscribe[watcher.property])
          this.subscribe[watcher.property] = []
        this.subscribe[watcher.property].push(watcher)
      }
      observe(data) {
        const that = this
        let handler = {
          get(target, property) {
            return target[property]
          },
          set(target, property, value) {
            let res = Reflect.set(target, property, value)
            that.subscribe[property].map(item => {
              item.update()
            })
            return res
          }
        }
        this.$data = new Proxy(data, handler)
      }
      compile(el) {
        const nodes = Array.prototype.slice.call(
          document.querySelector(el).children
        )
        let data = this.$data
        nodes.map(node => {
          if (node.children.length > 0) this._complie(node)
          if (node.hasAttribute('v-bind')) {
            let property = node.getAttribute('v-bind')
            this.publish(new Watcher(node, 'innerHTML', data, property))
          }
          if (node.hasAttribute('v-model')) {
            let property = node.getAttribute('v-model')
            this.publish(new Watcher(node, 'value', data, property))
            node.addEventListener('input', () => {
              data[property] = node.value
            })
          }
          if (node.hasAttribute('v-click')) {
            let methodName = node.getAttribute('v-click')
            let mothod = this.$methods[methodName].bind(data)
            node.addEventListener('click', mothod)
          }
        })
      }
    }
    class Watcher {
      constructor(node, attr, data, property) {
        this.node = node
        this.attr = attr
        this.data = data
        this.property = property
      }
      update() {
        this.node[this.attr] = this.data[this.property]
      }
    }
    // 渲染todolist列表
    const Render = {
      // 初始化
      init: function(arr) {
        const fragment = document.createDocumentFragment()
        for (let i = 0; i < arr.length; i++) {
          const li = document.createElement('li')
          li.textContent = arr[i]
          fragment.appendChild(li)
        }
        list.appendChild(fragment)
      },
      addList: function(val) {
        const li = document.createElement('li')
        li.textContent = val
        list.appendChild(li)
      }
    }
    // 实例化一个proxyVue
    window.onload = function() {
      let vm = new proxyVue({
        el: '#app',
        data: {
          num: 0,
          arr: []
        },
        methods: {
          addList() {
            this.arr.push(this.num)
            Render.addList(this.num)
          }
        }
      })
    }
  </script>
</html>
```

```js
const Observer = function(data) {
  // 循环修改为每个属性添加get set
  for (let key in data) {
    defineReactive(data, key)
  }
}

const defineReactive = function(obj, key) {
  // 局部变量dep，用于get set内部调用
  const dep = new Dep()
  // 获取当前值
  let val = obj[key]
  Object.defineProperty(obj, key, {
    // 设置当前描述属性为可被循环
    enumerable: true,
    // 设置当前描述属性可被修改
    configurable: true,
    get() {
      console.log('in get')
      // 调用依赖收集器中的addSub，用于收集当前属性与Watcher中的依赖关系
      dep.depend()
      return val
    },
    set(newVal) {
      if (newVal === val) {
        return
      }
      val = newVal
      // 当值发生变更时，通知依赖收集器，更新每个需要更新的Watcher，
      // 这里每个需要更新通过什么断定？dep.subs
      dep.notify()
    }
  })
}

const observe = function(data) {
  return new Observer(data)
}

const Vue = function(options) {
  const self = this
  // 将data赋值给this._data，源码这部分用的Proxy所以我们用最简单的方式临时实现
  if (options && typeof options.data === 'function') {
    this._data = options.data.apply(this)
  }
  // 挂载函数
  this.mount = function() {
    new Watcher(self, self.render)
  }
  // 渲染函数
  this.render = function() {
    with (self) {
      _data.text
    }
  }
  // 监听this._data
  observe(this._data)
}

const Watcher = function(vm, fn) {
  const self = this
  this.vm = vm
  // 将当前Dep.target指向自己
  Dep.target = this
  // 向Dep方法添加当前Wathcer
  this.addDep = function(dep) {
    dep.addSub(self)
  }
  // 更新方法，用于触发vm._render
  this.update = function() {
    console.log('in watcher update')
    fn()
  }
  // 这里会首次调用vm._render，从而触发text的get
  // 从而将当前的Wathcer与Dep关联起来
  this.value = fn()
  // 这里清空了Dep.target，为了防止notify触发时，不停的绑定Watcher与Dep，
  // 造成代码死循环
  Dep.target = null
}

const Dep = function() {
  const self = this
  // 收集目标
  this.target = null
  // 存储收集器中需要通知的Watcher
  this.subs = []
  // 当有目标时，绑定Dep与Wathcer的关系
  this.depend = function() {
    if (Dep.target) {
      // 这里其实可以直接写self.addSub(Dep.target)，
      // 没有这么写因为想还原源码的过程。
      Dep.target.addDep(self)
    }
  }
  // 为当前收集器添加Watcher
  this.addSub = function(watcher) {
    self.subs.push(watcher)
  }
  // 通知收集器中所的所有Wathcer，调用其update方法
  this.notify = function() {
    for (let i = 0; i < self.subs.length; i += 1) {
      self.subs[i].update()
    }
  }
}

const vue = new Vue({
  data() {
    return {
      text: 'hello world'
    }
  }
})

vue.mount() // in get
vue._data.text = '123' // in watcher update /n in get
```

- vue 将 data 初始化为一个 Observer 并对对象中的每个值，重写了其中的 get、set，data 中的每个 key，都有一个独立的依赖收集器。
- 在 get 中，向依赖收集器添加了监听
- 在 mount 时，实例了一个 Watcher，将收集器的目标指向了当前 Watcher
- 在 data 值发生变更时，触发 set，触发了依赖收集器中的所有监听的更新，来触发 Watcher.update

## 参考

[面试题：你能写一个 Vue 的双向数据绑定吗？](https://juejin.im/post/5acc17cb51882555745a03f8)

[vue3.0 尝鲜 -- 摒弃 Object.defineProperty，基于 Proxy 的观察者机制探索](https://juejin.im/post/5bf3e632e51d452baa5f7375)

[当面试官问你 Vue 响应式原理，你可以这么回答他](https://juejin.im/post/5adf0085518825673123da9a)
