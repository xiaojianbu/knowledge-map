# 双向绑定

1. 事件机制（pub/sub）：我们通过特定的方法修改数据，例如 Store.set('key', 'value')，set 方法修改数据的同时触发一个事件，告诉 view 数据发生了更改，view 立即从新从 store 拉取数据。这类似于 Flux 中 View 对于 Store 数据的响应，只不过通过某种方法或者 directive 将这种机制封装起来了。这种机制的弱势在于你没法用传统的方式等号=对数据进行赋值。
2. 轮询（pull/dirty check）：这个方式就更加简单了，数据的消费方不断的检测数据有没有修改。当然不是无时无刻的进行检测，而是在 input 事件或者 change 事件的时候进行检测。Angular 1.0 使用的就是这种机制。我个人倾向于把这种方式称为轮询而不是脏检查
3. Javascript 中，我们可以给对象中的值定义访问器 Object 天生的支持的属性访问器 defineProperty。那么接下来当你每次想访问 data 中 key 字段时，无论是取值 data.key 还是赋值 data.key = 'Hi'，都会有打印信息。这也意味着，我们能够在用户执行普通的赋值和取值操作时，做一些事情，例如通知数据的消费者数据发生了更改，让它们重新编译模板。这也就是 Vue.js 双向绑定的思路。当然这只是双向数据绑定的一个环节，但是是最核心的环节，其他还包括如何添加订阅者，如何编译模板


在初始化 data props 时，递归对象，给每一个属性双向绑定，对于数组而言，会拿到原型重写函数，实现手动派发更新。因为函数不能监听到数据的变动，和 proxy 比较一下。
除了以上数组函数，通过索引改变数组数据或者给对象添加新属性也不能触发，需要使用自带的set 函数，这个函数内部也是手动派发更新
在组件挂载时，会实例化渲染观察者，传入组件更新的回调。在实例化过程中，会对模板中的值对象进行求值，触发依赖收集。在触发依赖之前，会保存当前的渲染观察者，用于组件含有子组件的时候，恢复父组件的观察者。触发依赖收集后，会清理掉不需要的依赖，性能优化，防止不需要的地方去重复渲染。
改变值会触发依赖更新，会将收集到的所有依赖全部拿出来，放入 nextTick 中统一执行。执行过程中，会先对观察者进行排序，渲染的最后执行。先执行 beforeupdate 钩子函数，然后执行观察者的回调。在执行回调的过程中，可能 watch 会再次 push 进来，因为存在在回调中再次赋值，判断无限循环。

作者：yck
链接：https://juejin.im/post/5ba34e54e51d450e5162789b
来源：掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
