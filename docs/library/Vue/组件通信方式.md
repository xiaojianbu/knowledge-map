# 组件通信

## Vue 的父子通信

使用 v-model 实现父传子，子传父。因为 v-model 默认解析成 :value 和 :input

### 父传子

通过 props
通过 \$children 访问子组件数组，注意该数组乱序
对于多级父传子，可以使用 v-bind={$attrs} 传入内部组件，通过对象的方式筛选出父组件中传入但子组件不需要的 props (class 和 style 除外)
\$listens 包含了父作用域中的 (不含  .native  修饰器的) v-on 事件监听器,以通过 v-on="$listeners" 传入内部组件。
provide/inject

以允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效。

文档：provide 和 inject 绑定并不是可响应的。这是刻意为之的。然而，如果你传入了一个可监听的对象，那么其对象的属性还是可响应的。

```js
// A.vue
export default {
  provide: {
    name: '1'
  }
}

// B.vue
export default {
  inject: ['name'],
  mounted () {
    console.log(this.name);  // 1
  }
}

```

### 子传父

父组件传递函数给子组件，子组件通过 $emit 触发
修改父组件的 props
通过 $parent 访问父组件
.sync

### 平行组件

```js
// 通过一个空的Vue实例作为中央事件总线（事件中心），用它来触发事件和监听事件
var Event = new Vue()
Event.$emit(事件名, 数据)
Event.$on(事件名, data => {})
```

EventBus

[events](https://github.com/Gozala/events/blob/master/events.js)

```js
class EventEmitter {
  constructor() {
    this._events = this._events || new Map() // 储存事件/回调键值对
    this._maxListeners = this._maxListeners || 10 // 设立监听上限
  }
}

// 触发名为type的事件
EventEmitter.prototype.emit = function(type, ...args) {
  let handler
  // 从储存事件键值对的this._events中获取对应事件回调函数
  handler = this._events.get(type)
  if (args.length > 0) {
    handler.apply(this, args)
  } else {
    handler.call(this)
  }
  return true
}

// 监听名为type的事件
EventEmitter.prototype.addListener = function(type, fn) {
  // 将type事件以及对应的fn函数放入this._events中储存
  if (!this._events.get(type)) {
    this._events.set(type, fn)
  }
}
// 实例化
const emitter = new EventEmitter()

// 监听一个名为arson的事件对应一个回调函数
emitter.addListener('arson', man => {
  console.log(`expel ${man}`)
})

// 我们触发arson事件,发现回调成功执行
emitter.emit('arson', 'low-end') // expel low-end
// 重复监听同一个事件名
emitter.addListener('arson', man => {
  console.log(`expel ${man}`)
})
emitter.addListener('arson', man => {
  console.log(`save ${man}`)
})

emitter.emit('arson', 'low-end') // expel low-end

// 触发名为type的事件
EventEmitter.prototype.emit = function(type, ...args) {
  let handler
  handler = this._events.get(type)
  if (Array.isArray(handler)) {
    // 如果是一个数组说明有多个监听者,需要依次此触发里面的函数
    for (let i = 0; i < handler.length; i++) {
      if (args.length > 0) {
        handler[i].apply(this, args)
      } else {
        handler[i].call(this)
      }
    }
  } else {
    // 单个函数的情况我们直接触发即可
    if (args.length > 0) {
      handler.apply(this, args)
    } else {
      handler.call(this)
    }
  }

  return true
}

// 监听名为type的事件
EventEmitter.prototype.addListener = function(type, fn) {
  const handler = this._events.get(type) // 获取对应事件名称的函数清单
  if (!handler) {
    this._events.set(type, fn)
  } else if (handler && typeof handler === 'function') {
    // 如果handler是函数说明只有一个监听者
    this._events.set(type, [handler, fn]) // 多个监听者我们需要用数组储存
  } else {
    handler.push(fn) // 已经有多个监听者,那么直接往数组里push函数即可
  }
}
// 监听同一个事件名
emitter.addListener('arson', man => {
  console.log(`expel ${man}`)
})
emitter.addListener('arson', man => {
  console.log(`save ${man}`)
})

emitter.addListener('arson', man => {
  console.log(`kill ${man}`)
})

// 触发事件
emitter.emit('arson', 'low-end')
//expel low-end
//save low-end
//kill low-end
EventEmitter.prototype.removeListener = function(type, fn) {
  const handler = this._events.get(type) // 获取对应事件名称的函数清单

  // 如果是函数,说明只被监听了一次
  if (handler && typeof handler === 'function') {
    this._events.delete(type, fn)
  } else {
    let position
    // 如果handler是数组,说明被监听多次要找到对应的函数
    for (let i = 0; i < handler.length; i++) {
      if (handler[i] === fn) {
        position = i
      } else {
        position = -1
      }
    }
    // 如果找到匹配的函数,从数组中清除
    if (position !== -1) {
      // 找到数组对应的位置,直接清除此回调
      handler.splice(position, 1)
      // 如果清除后只有一个函数,那么取消数组,以函数形式保存
      if (handler.length === 1) {
        this._events.set(type, handler[0])
      }
    } else {
      return this
    }
  }
}
```

// 参照 vue 源码实现

```js
var EventEmitter = function() {
  this._events = {}
}
EventEmitter.prototype.on = function(event, cb) {
  if (Array.isArray(event)) {
    for (let i = 0, l = event.length; i < l; i++) {
      this.on(event[i], cb)
    }
  } else {
    ;(this._events[event] || (this._events[event] = [])).push(cb)
  }
  return this
}
EventEmitter.prototype.once = function(event, cb) {
  function on() {
    this.off(event, cb)
    cb.apply(this, arguments)
  }
  on.fn = cb
  this.on(event, on)
  return this
}
EventEmitter.prototype.off = function(event, cb) {
  if (!arguments.length) {
    this._events = Object.create(null)
    return this
  }
  if (Array.isArray(event)) {
    for (let i = 0, l = event.length; i < l; i++) {
      this.off(event[i], cb)
    }
    return this
  }
  if (!cb) {
    this._events[event] = null
    return this
  }
  if (cb) {
    let cbs = this._events[event]
    let i = cbs.length
    while (i--) {
      if (cb === cbs[i] || cb === cbs[i].fn) {
        cbs.splice(i, 1)
        break
      }
    }
    return this
  }
}
EventEmitter.prototype.emit = function(event, ...args) {
  let cbs = this._events[event]
  if (cbs) {
    for (let i = 0, l = cbs.length; i < l; i++) {
      cbs[i].apply(this, args)
    }
  }
}
```

## Vuex 解决一切

## 参考

[Vue.js 父子组件通信的 1212 种方式](https://juejin.im/post/5bd18c72e51d455e3f6e4334)
[Vue 组件间通信方式完整版](https://zhuanlan.zhihu.com/p/60250686)

[EventEmitter]https://juejin.im/post/5ac2fb886fb9a028b86e328c
