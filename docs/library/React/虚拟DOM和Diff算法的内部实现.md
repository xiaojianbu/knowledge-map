# 虚拟 DOM 和 Diff 算法的内部实现

## diff 算法

### 异步渲染和旧版的 diff 的区别

传统 diff 算法的问题

传统的 diff 算法是使用循环递归对节点进行依次对比，复杂度为 O(n^3),效率低下

React diff 算法策略

- 针对树结构(tree diff)：对 UI 层的 DOM 节点跨层级的操作进行忽略。（数量少）
- 针对组件结构(component diff)：拥有相同类的两个组件生成相似的树形结构，拥有不同类的两个组件会生成不同的属性结构。
- 针对元素结构(element-diff): 对于同一层级的一组节点，使用具有唯一性的 id 区分 (key 属性)

#### tree diff 的特点

React 通过使用 updateDepth 对 虚拟 DOM 树进行层次遍历

两棵树只对同一层级节点进行比较，只要该节点不存在了，那么该节点与其所有子节点会被完全删除,不在进行进一步比较。

只需要遍历一次，便完成对整个 DOM 树的比较。

#### component diff 的特点

- 同一类型的组件，按照原策略(tree diff)比较 virtual DOM tree
- 同类型组件，组件 A 转化为了组件 B，如果 virtual DOM 无变化，可以通过 shouldComponentUpdate()方法来判断是否
- 不同类型的组件，那么 diff 算法会把要改变的组件判断为 dirty component,从而替换整个组件的所有节点。

#### element diff 特点

对于处于同一层级的节点，React diff 提供了三种节点操作: 插入，移动，删除

- 插入： 新的组件不在原来的集合中，而是全新的节点，则对集合进行插入操作。
- 删除：组件已经在集合中，但集合已经更新，此时节点就需要删除。
- 移动：组件已经存在于集合中，并且集合更新时，组件并没有发生更新，只是位置发生改变，例如：(A,B,C,D) → (A,D,B,C), 如果为传统 diff 则会在检测到旧集合中第二位为 B，新集合第二位为 D 时删除 B，插入 D，并且后面的所有节点都要重新加载，而 React diff 则是通过向同一层的节点添加 唯一 key 进行区分，并且移动。

### diff 如何实现

### react 旧版的 diff 用深度优先还是广度优先

为什么用深度优先，广度优先能实现吗（其实我认为广度也能实现的，面试官问广度有啥不好，我确实不知道..）
