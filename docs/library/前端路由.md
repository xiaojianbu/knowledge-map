# 前端路由

传统的 web 开发模式里，路由都是由服务端控制并管理，根据不同的 url 映射不同的页面。而 Ajax 的出现，使得前端路由成为可能。

## 什么是前端路由

路由就是浏览器地址栏中的 url 与所见网页的对应关系。

传统的服务端路由，根据客户端请求的不同网址，返回不同的网页内容，这种情况一是会造成服务器压力增加，二是每次都重新请求，响应较慢、用户体验下降。于是，单页应用（spa,single page application）应运而生。在 url 地址改变的过程中，通过 js 来实现不同 UI 之间的切换（js 对 DOM 的操作），而不再向服务器重新请求页面，只通过 ajax 向服务端请求数据，对用户来说这种无刷新的、即时响应是更好的体验。其中，根据 url 地址栏的变化而展示不同的 UI，就是通过前端路由来实现的。目前主流的支持单页应用的前端框架，基本都有配套的或第三方的路由系统。

## 原理

以 hash 形式（也可以使用 History API 来处理）为例，当 url 的 hash 发生变化时，触发 hashchange 注册的回调，回调中去进行不同的操作，进行不同的内容的展示。

```js
function Router() {
  this.routes = {}
  this.currentUrl = ''
}
Router.prototype.route = function(path, callback) {
  this.routes[path] = callback || function() {}
}
Router.prototype.refresh = function() {
  this.currentUrl = location.hash.slice(1) || '/'
  this.routes[this.currentUrl]()
}
Router.prototype.init = function() {
  window.addEventListener('load', this.refresh.bind(this), false)
  window.addEventListener('hashchange', this.refresh.bind(this), false)
}
window.Router = new Router()
window.Router.init()
```

上面路由系统 Router 对象实现，主要提供三个方法

1. init 监听浏览器 url hash 更新事件
2. route 存储路由更新时的回调到回调数组 routes 中，回调函数将负责对页面的更新
3. refresh 执行当前 url 对应的回调函数，更新页面

Router 调用方式以及呈现效果如下：点击触发 url 的 hash 改变，并对应地更新内容（这里为 body 背景色）

```js
;<ul>
  <li>
    <a href='#/'>turn white</a>
  </li>
  <li>
    <a href='#/blue'>turn blue</a>
  </li>
  <li>
    <a href='#/green'>turn green</a>
  </li>
</ul>
var content = document.querySelector('body')
// change Page anything
function changeBgColor(color) {
  content.style.backgroundColor = color
}
Router.route('/', function() {
  changeBgColor('white')
})
Router.route('/blue', function() {
  changeBgColor('blue')
})
Router.route('/green', function() {
  changeBgColor('green')
})
```

```js
class Routers {
  constructor() {
    // 储存hash与callback键值对
    this.routes = {}
    // 当前hash
    this.currentUrl = ''
    // 记录出现过的hash
    this.history = []
    // 作为指针,默认指向this.history的末尾,根据后退前进指向history中不同的hash
    this.currentIndex = this.history.length - 1
    this.refresh = this.refresh.bind(this)
    this.backOff = this.backOff.bind(this)
    // 默认不是后退操作
    this.isBack = false
    window.addEventListener('load', this.refresh, false)
    window.addEventListener('hashchange', this.refresh, false)
  }

  route(path, callback) {
    this.routes[path] = callback || function() {}
  }

  refresh() {
    this.currentUrl = location.hash.slice(1) || '/'
    if (!this.isBack) {
      // 如果不是后退操作,且当前指针小于数组总长度,直接截取指针之前的部分储存下来
      // 此操作来避免当点击后退按钮之后,再进行正常跳转,指针会停留在原地,而数组添加新hash路由
      // 避免再次造成指针的不匹配,我们直接截取指针之前的数组
      // 此操作同时与浏览器自带后退功能的行为保持一致
      if (this.currentIndex < this.history.length - 1)
        this.history = this.history.slice(0, this.currentIndex + 1)
      this.history.push(this.currentUrl)
      this.currentIndex++
    }
    this.routes[this.currentUrl]()
    console.log('指针:', this.currentIndex, 'history:', this.history)
    this.isBack = false
  }
  // 后退功能
  backOff() {
    // 后退操作设置为true
    this.isBack = true
    this.currentIndex <= 0
      ? (this.currentIndex = 0)
      : (this.currentIndex = this.currentIndex - 1)
    location.hash = `#${this.history[this.currentIndex]}`
    this.routes[this.history[this.currentIndex]]()
  }
}
```

```js
class Routers {
  constructor() {
    this.routes = {}
    // 在初始化时监听popstate事件
    this._bindPopState()
  }
  // 初始化路由
  init(path) {
    history.replaceState({ path: path }, null, path)
    this.routes[path] && this.routes[path]()
  }
  // 将路径和对应回调函数加入hashMap储存
  route(path, callback) {
    this.routes[path] = callback || function() {}
  }

  // 触发路由对应回调
  go(path) {
    history.pushState({ path: path }, null, path)
    this.routes[path] && this.routes[path]()
  }
  // 监听popstate事件
  _bindPopState() {
    window.addEventListener('popstate', e => {
      const path = e.state && e.state.path
      this.routes[path] && this.routes[path]()
    })
  }
}
```

### 基于 hash（location.hash+hashchange 事件）

location.hash 的值是 url 中#后面的内容，如http://www.163.com#netease 此网址中，location.hash='#netease'。hash 满足以下几个特性，才使得其可以实现前端路由：

- url 中 hash 值的变化并不会重新加载页面，因为 hash 是用来指导浏览器行为的，对服务端是无用的，所以不会包括在 http 请求中。
- hash 值的改变，都会在浏览器的访问历史中增加一个记录，也就是能通过浏览器的回退、前进按钮控制 hash 的切换
- 我们可以通过 hashchange 事件，监听到 hash 值的变化，从而响应不同路径的逻辑处理

可以在 hashchange 事件里，根据 hash 值来更新对应的视图，但不会去重新请求页面，同时呢，也在 history 里增加了一条访问记录，用户也仍然可以通过前进后退键实现 UI 的切换。

触发 hash 值的变化有 2 种方法:

一种是通过 a 标签，设置 href 属性，当标签点击之后，地址栏会改变，同时会触发 hashchange 事件

另一种是通过 js 直接赋值给 location.hash，也会改变 url，触发 hashchange 事件。

```js
// hash实现的简易路由
function Router() {
  this.routes = {}
  this.currentUrl = ''
}

Router.prototype.route = function(path, callback) {
  this.routes[path] = callback || function() {}
}

Router.prototype.refresh = function() {
  this.currentUrl = location.hash.slice(1) || '/'
  this.routes[this.currentUrl]()
}

Router.prototype.init = function() {
  window.addEventListener('load', this.refresh.bind(this), false)
  window.addEventListener('hashchange', this.refresh.bind(this), false)
}

window.Router = new Router()
window.Router.init()

// 添加路由规则
Router.route('/', function() {
  // 设置响应内容
})

Router.route('/test', function() {
  // 设置响应内容
})
```

### 基于 History 新 API（history.pushState()+popState 事件）

HTML5 中 history 对象上新的 API，同样能实现前端的路由。通过 pushState()方法或 replaceState()方法可以修改 url 的地址，并在 popstate 事件中能监听地址的改变，不同的是，调用 history.pushState()或者 history.replaceState()不会触发 popstate 事件。

history.pushState 和 history.replaceState，这两个 API 都接收三个参数：

- 状态对象（state object），一个 JavaScript 对象，与用 pushState()方法创建的新历史记录条目关联。无论何时用户导航到新创建的状态，会触发 popstate 事件，并能在事件中使用该对象。
- 标题（title） ：传入一个短标题给当前 state。现在大多数浏览器不支持或者会忽略此参数，最好传入 null 代替；
- 地址（URL）：新的历史记录条目的地址。浏览器不会在调用 pushState()方法后加载该地址，但之后，可能会试图加载，例如用户重启浏览器。新的 URL 不一定是绝对路径；如果是相对路径，它将以当前 URL 为基准；传入的 URL 与当前 URL 应该是同源的，否则，pushState()会抛出异常。该参数是可选的；不指定的话则为文档当前 URL。

pushState 会增加一条新的历史记录，而 replaceState 则会替换当前的历史记录。这两个 api，加上 state 改变触发的 popstate 事件，提供了单页应该的另一种路由方式。

```js
class Routers {
  constructor() {
    this.routes = {}
    // 在初始化时监听popstate事件
    this._bindPopState()
  }
  // 初始化路由
  init(path) {
    history.replaceState({ path: path }, null, path)
    this.routes[path] && this.routes[path]()
  }
  // 将路径和对应回调函数加入hashMap存储
  route(path, callback) {
    this.routes[path] = callback || function() {}
  }
  // 触发路由对应回调
  go(path) {
    history.pushState({ path: path }, null, path)
    this.routes[path] && this.routes[path]()
  }
  // 监听popstate事件
  _bindPopState() {
    window.addEventListener('popstate', e => {
      const path = e.state && e.state.path
      this.routes[path] && this.routes[path]()
    })
  }
}
```

在 history 下当刷新时，如果服务器中没有相应的响应或者资源，会 404。服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面

## 参考

[面试官: 你了解前端路由吗?](https://juejin.im/post/5ac61da66fb9a028c71eae1b)

[前端路由实现与 react-router 源码分析](https://github.com/joeyguo/blog/issues/2)

[前端路由原理解析和实现](https://github.com/whinc/blog/issues/13)

[前端路由简介以及 vue-router 实现原理](https://github.com/muwoo/blogs/issues/22)
