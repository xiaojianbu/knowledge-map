# 性能优化

1. 压缩代码(JS/CSS),压缩图片
2. 合并一些小图片(css sprite) 优化图片，使用 base64 代替小图
3. 若是打包的代码尽可能切割成多个 chunk,减少单一 chunk 过大
4. 静态文件采用 cdn 引入
5. HTTP 的缓存头使用的合理
6. 减小第三方库的依赖
7. 对于代码应该考虑性能来编写,比如使用 requestAnimationFrame 绘制动画,尽可能减少页面重绘(DOM 改变)
8. 减少 HTTP 请求数
9. 减少 DNS 查询
10. 避免重定向
11. 图片懒加载
12. 减少 DOM 元素数量
13. 减少 DOM 操作
14. 使用 gzip
15. 拆分模块，按需加载

## 浏览器

### 同一时间从一个域名下载多少资源

不同浏览器有不同数量限制，但一般均在 4-6 个

由于有并发请求数量的限制，所以将诸如图片等放在其他域名上，可以实现资源的并发下载。

## 运算结果缓存

由于 JavaScript 中的函数也是对象（JavaScript 中一切都是对象），所以我们可以给函数添加任意的属性。这也就为我们提供符合备忘录模式的缓存运算结果的功能，比如我们有一个需要大量运算才能得出结果的函数如下：

```js
function calculator(params) {
  //大量的耗时的计算
  return result
}
```

如果其中不涉及随机，参数一样时所返回的结果一致，我们就可以将运算结果进行缓存从而避免重复的计算：

```js
function calculator(params) {
  var cacheKey = JSON.stringify(params)
  var cache = calculator.cache || {}
  if (typeof cache[cacheKey] !== 'undefined') {
    return cache[cacheKey]
  }
  //大量耗时的计算
  cache[cacheKey] = result
  return result
}
```

这里将参数转化为 JSON 字符串作为 key，如果这个参数已经被计算过，那么就直接返回，否则进行计算。计算完毕后再添加入 cache 中，如果需要，可以直接查看 cache 的内容：calculator.cache

这种方式并不适用于如下场合：

- 相同参数可能产生不同结果的情况（包含随机数之类的）
- 运算结果占用特别多内存的情况

## 让垃圾回收器回收那些不再需要的对象

### delete

一种方式是通过 delete 方式来消除对象中的键值对，从而消除引用。但这种方式并不提倡，它会改变对象的结构，可能导致引擎中对对象的存储方式变更，不利于 JavaScript 引擎的优化

### null

另一种方式是通过将值设为 null 来消除引用。通过将变量或对象的属性设为 null，可以消除引用，使原本引用的对象成为一个“孤岛”，然后在垃圾回收的时候对其进行回收。

### 事件处理器的回收

在某些 DOM 节点绑定的事件处理器不需要后，我们应当销毁它们。同时绑定的时候也尽量使用事件代理的方式进行绑定，以免造成多次重复的绑定导致内存空间的浪费

### 闭包导致的内存泄露

尽量将闭包中的内存大的变量修改为内存小的变量

## 对象的优化

### 缓存需要被使用的对象

JavaScript 获取数据的性能有如下顺序（从快到慢）：变量获取 > 数组下标获取（对象的整数索引获取） > 对象属性获取（对象非整数索引获取）

### 考虑对象和数组

在 JavaScript 中我们可以使用两种存放数据：对象和数组。由于 JavaScript 数组可以存放任意类型数据这样的灵活性，导致我们经常需要考虑何时使用数组，何时使用对象。我们应当在如下情况下做出考虑：

- 存储一串相同类型的对象，应当使用数组
- 存储一堆键值对，值的类型多样，应当使用对象
- 所有值都是通过整数索引，应当使用数组

### 对象的拷贝

需要注意的是，JavaScript 遍历对象和数组时，使用 for...in 的效率相当低，所以在拷贝对象时，如果已知需要被拷贝的对象的属性，通过直接赋值的方式比使用 for...in 方式要来得快

## 缓存 AJAX

### 函数缓存

我们可以使用前面缓存复杂计算函数结果的方式进行缓存，通过在函数对象上构造 cache 对象，原理一样，这里略过。这种方式是精确到函数，而不精确到请求.

## 使用 requestAnimationFrame 来实现视觉变化

```js
/**
 * If run as a requestAnimationFrame callback, this
 * will be run at the start of the frame.
 */
function updateScreen(time) {
  // Make visual updates here.
}

requestAnimationFrame(updateScreen)
```

### 什么是 fps，60fps 意味着什么？

fps（frames per second），指一秒内屏幕刷新的次数或者动画在一秒内更新的帧数。现代浏览器大多每秒刷新 60 次，为了和设备的刷新频率保持一致，动画也要保证每秒 60 更新帧。如果低于 60 fps，称动画发生了掉帧，如果掉帧严重，用户则能够明显地感觉到卡顿。高的帧率，意味着更连贯的动画，更流畅的滚动，这些总是能带来极好的用户体验。

## 降低复杂性或使用 Web Worker

在许多情况下，可以将纯计算工作移到 Web Worker

```js
var dataSortWorker = new Worker('sort-work.js')
dataSortWorker.postMessage(dataToSort)
// The main thread is now free to continue working on other things..

dataSortWorker.addEventListener('message', function(evt) {
  var sortedData = evt.data
  // Update data on screen...
})
```

## 来源

[前端性能优化（JavaScript 篇）](https://segmentfault.com/a/1190000000490324)
