# 跨域

同源策略是浏览器的一个安全功能，不同源的客户端脚本在没有明确授权的情况下，不能读写对方资源。若地址里面的协议、域名和端口号均相同则属于同源。

jsonp 跨域、nginx 反向代理、node.js 中间件代理跨域、后端设置 http header、后端在服务器上设置 cors。

## 什么是跨域

跨域是指一个域下的文档或脚本试图去请求另一个域下的资源，这里跨域是广义的。

广义的跨域：

1. 资源跳转： A 链接、重定向、表单提交
2. 资源嵌入：、script、等 dom 标签，还有样式中 background:url()、@font-face()等文件外链
3. 脚本请求： js 发起的 AJAX 请求、dom 和 js 对象的跨域操作等

其实我们通常所说的跨域是狭义的，是由浏览器同源策略限制的一类请求场景。

## 什么是同源策略

同源策略/SOP（Same origin policy）是一种约定，由 Netscape 公司 1995 年引入浏览器，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到 XSS、CSFR 等攻击。所谓同源是指”协议+域名+端口”三者相同，即便两个不同的域名指向同一个 ip 地址，也非同源。

那么同源策略的作用是什么呢？同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制。

那么我们又为什么需要跨域呢？一是前端和服务器分开部署，接口请求需要跨域，二是我们可能会加载其它网站的页面作为 iframe 内嵌。

同源策略限制以下几种行为：

1. Cookie、LocalStorage 和 IndexDB 无法读取
2. DOM 和 Js 对象无法获得
3. AJAX 请求不能发送

## 常见跨域场景

```js
// URL 说明 是否允许通信
http://www.domain.com/a.js
http://www.domain.com/b.js 同一域名，不同文件或路径 允许
http://www.domain.com/lab/c.js
http://www.domain.com:8000/a.js
http://www.domain.com/b.js 同一域名，不同端口 不允许
http://www.domain.com/a.js
https://www.domain.com/b.js 同一域名，不同协议 不允许
http://www.domain.com/a.js
http://192.168.4.12/b.js 域名和域名对应相同 ip 不允许
http://www.domain.com/a.js
http://x.domain.com/b.js 主域相同，子域不同 不允许
http://domain.com/c.js
http://www.domain1.com/a.js
http://www.domain2.com/b.js 不同域名 不允许
```

跨域解决方案

1. 通过 jsonp 跨域
2. document.domain + iframe 跨域
3. location.hash + iframe
4. window.name + iframe 跨域
5. postMessage 跨域
6. 跨域资源共享（CORS）
7. nginx 代理跨域
8. nodejs 中间件代理跨域
9. WebSocket 协议跨域

## 通过 jsonp 跨域

通常为了减轻 web 服务器的负载，我们把 js、css，img 等静态资源分离到另一台独立域名的服务器上，在 html 页面中再通过相应的标签从不同域名下加载静态资源，而被浏览器允许，基于此原理，我们可以通过动态创建 script，再请求一个带参网址实现跨域通信。

尽管浏览器有同源策略，但是 script 标签的 src 属性不会被同源策略所约束，可以获取任意服务器上的脚本并执行。jsonp 通过插入 script 标签的方式来实现跨域，参数只能通过 url 传入，仅能支持 get 请求。

Step1: 创建 callback 方法

Step2: 插入 script 标签

Step3: 后台接受到请求，解析前端传过去的 callback 方法，返回该方法的调用，并且数据作为参数传入该方法

Step4: 前端执行服务端返回的方法调用

```js
var script = document.createElement('script')
script.type = 'text/javascript'

// 传参并指定回调执行函数为onBack
script.src = 'http://www.domain2.com:8080/login?user=admin&callback=onBack'
document.head.appendChild(script)

// 回调执行函数
function onBack(res) {
  alert(JSON.stringify(res))
}
//前端代码
function jsonp({ url, params, cb }) {
  return new Promise((resolve, reject) => {
    //创建script标签
    let script = document.createElement('script')
    //将回调函数挂在 window 上
    window[cb] = function (data) {
      resolve(data)
      //代码执行后，删除插入的script标签
      document.body.removeChild(script)
    }
    //回调函数加在请求地址上
    params = { ...params, cb } //wb=b&cb=show
    let arrs = []
    for (let key in params) {
      arrs.push(`${key}=${params[key]}`)
    }
    script.src = `${url}?${arrs.join('&')}`
    document.body.appendChild(script)
  })
}
//使用
function sayHi(data) {
  console.log(data)
}
jsonp({
  url: 'http://localhost:3000/say',
  params: {
    //code
  },
  cb: 'sayHi'
}).then((data) => {
  console.log(data)
})
//express启动一个后台服务
let express = require('express')
let app = express()

app.get('/say', (req, res) => {
  let { cb } = req.query //获取传来的callback函数名，cb是key
  res.send(`${cb}('Hello!')`)
})
app.listen(3000)
```

服务端返回如下（返回时即执行全局函数）：
onBack({"status": true, "user": "admin"})

后端 node.js 代码示例：

```js
var querystring = require('querystring')
var http = require('http')
var server = http.createServer()

server.on('request', function (req, res) {
  var params = qs.parse(req.url.split('?')[1])
  var fn = params.callback

  // jsonp返回设置
  res.writeHead(200, { 'Content-Type': 'text/javascript' })
  res.write(fn + '(' + JSON.stringify(params) + ')')

  res.end()
})

server.listen('8080')
console.log('Server is running at port 8080...')
```

jsonp 缺点：只能实现 get 一种请求。

## 跨域资源共享（CORS）

1. 与后端联调，Access-Control-Allow-Origin 设置一个白名单
2. 暂时不用联调, 使用 devServer.proxy(webpack)
3. 后端控制不了：在浏览器应用和 API 之间编写自己的代理。

对于“简单的” GET 或 POST 请求，如果服务器没有对其作出携带特殊 HTTP 头部的响应 -- 请求依然被发送并且数据也照样被返回，但浏览器将不允许 Javascript 访问该响应。

若请求包含了 cookie 的请求，或 Content-type 不是 **application/x-www-form-urlencoded**、**multipart/form-data**、**text-plain** 三者之一的，则被称为预检（preflight）的机制将被用到，并且一个 OPTIONS 请求会被发往服务器。

### Access-Control-Allow-

在 CORS 请求和响应中，都用到了一些 HTTP 头部：

- Origin 该头部是客户端发起的请求的一部分，包含了应用所在的域。由于安全原因，浏览器不会允许用户重写这个值。
- Access-Control-Allow-Credentials 该头部只需要在服务器支持通过 cookie 认证的情况下出现在响应中。这种情况下，其唯一合法值就是 true。
- Access-Control-Allow-Methods 一个逗号分隔的、表示服务器将会支持的 HTTP 请求动词（如 GET, POST）列表。
- Access-Control-Allow-Headers 格式为一个逗号分隔的列表，表示服务器将会支持的请求头部值。如果使用了自定义头部（比如 x-authentication-token），则应该将其置于这个 ACA 头部（译注：即 Access-Control-Allow-Headers）响应中，并返回到 OPTIONS 调用中；除非该请求被阻塞了。
- Access-Control-Expose-Headers 该响应应包含一个头部列表，表示将在实际的响应中出现的值，并应在客户端中有效。所有其他头部则会被限制。

### 解决 CORS

普通跨域请求：只服务端设置 Access-Control-Allow-Origin 即可，前端无须设置。

带 cookie 请求：前后端都需要设置字段，另外需注意：所带 cookie 为跨域请求接口所在域的 cookie，而非当前页。

## document.domain + iframe 跨域

此方案仅限主域相同，子域不同的跨域应用场景。

实现原理：两个页面都通过 js 强制设置 document.domain 为基础主域，就实现了同域。

1.）父窗口：(http://www.domain.com/a.html)

```html
<iframe id="iframe" src="http://child.domain.com/b.html"></iframe>
```

```js
document.domain = 'domain.com'
var user = 'admin'
```

2.）子窗口：(http://child.domain.com/b.html)

```js
document.domain = 'domain.com'
// 获取父窗口中变量
alert('get js data from parent ---> ' + window.parent.user)
```

## location.hash + iframe 跨域

实现原理： a 欲与 b 跨域相互通信，通过中间页 c 来实现。 三个页面，不同域之间利用 iframe 的 location.hash 传值，相同域之间直接 js 访问来通信。

具体实现：A 域：a.html -> B 域：b.html -> A 域：c.html，a 与 b 不同域只能通过 hash 值单向通信，b 与 c 也不同域也只能单向通信，但 c 与 a 同域，所以 c 可通过 parent.parent 访问 a 页面所有对象。

1.）a.html：(http://www.domain1.com/a.html)

```html
<iframe
  id="iframe"
  src="http://www.domain2.com/b.html"
  style="display:none;"
></iframe>
```

```js
var iframe = document.getElementById('iframe')

// 向b.html传hash值
setTimeout(function () {
  iframe.src = iframe.src + '#user=admin'
}, 1000)

// 开放给同域c.html的回调方法
function onCallback(res) {
  alert('data from c.html ---> ' + res)
}
```

2.）b.html：(http://www.domain2.com/b.html)

```html
<iframe
  id="iframe"
  src="http://www.domain1.com/c.html"
  style="display:none;"
></iframe>
```

```js
var iframe = document.getElementById('iframe')

// 监听a.html传来的hash值，再传给c.html
window.onhashchange = function () {
  iframe.src = iframe.src + location.hash
}
```

3.）c.html：(http://www.domain1.com/c.html)

```js
// 监听b.html传来的hash值
window.onhashchange = function () {
  // 再通过操作同域a.html的js回调，将结果传回
  window.parent.parent.onCallback(
    'hello: ' + location.hash.replace('#user=', '')
  )
}
```

## window.name + iframe 跨域

window.name 属性的独特之处：name 值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）。

1.）a.html：(http://www.domain1.com/a.html)

```js
var proxy = function (url, callback) {
  var state = 0
  var iframe = document.createElement('iframe')

  // 加载跨域页面
  iframe.src = url

  // onload事件会触发2次，第1次加载跨域页，并留存数据于window.name
  iframe.onload = function () {
    if (state === 1) {
      // 第2次onload(同域proxy页)成功后，读取同域window.name中数据
      callback(iframe.contentWindow.name)
      destoryFrame()
    } else if (state === 0) {
      // 第1次onload(跨域页)成功后，切换到同域代理页面
      iframe.contentWindow.location = 'http://www.domain1.com/proxy.html'
      state = 1
    }
  }

  document.body.appendChild(iframe)

  // 获取数据以后销毁这个iframe，释放内存；这也保证了安全（不被其他域frame js访问）
  function destoryFrame() {
    iframe.contentWindow.document.write('')
    iframe.contentWindow.close()
    document.body.removeChild(iframe)
  }
}

// 请求跨域 b 页面数据
proxy('http://www.domain2.com/b.html', function (data) {
  alert(data)
})
```

2.）proxy.html：(http://www.domain1.com/proxy….
中间代理页，与 a.html 同域，内容为空即可。

3.）b.html：(http://www.domain2.com/b.html)

```js
window.name = 'This is domain2 data!'
```

总结：通过 iframe 的 src 属性由外域转向本地域，跨域数据即由 iframe 的 window.name 从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。

## postMessage 跨域

postMessage 是 HTML5 XMLHttpRequest Level 2 中的 API，且是为数不多可以跨域操作的 window 属性之一，它可用于解决以下方面的问题：
a.） 页面和其打开的新窗口的数据传递
b.） 多窗口之间消息传递
c.） 页面与嵌套的 iframe 消息传递
d.） 上面三个场景的跨域数据传递

用法：postMessage(data,origin)方法接受两个参数
data： html5 规范支持任意基本类型或可复制的对象，但部分浏览器只支持字符串，所以传参时最好用 JSON.stringify()序列化。
origin： 协议+主机+端口号，也可以设置为”\*”，表示可以传递给任意窗口，如果要指定和当前窗口同源的话设置为”/”。

1.）a.html：(http://www.domain1.com/a.html)

```html
<iframe
  id="iframe"
  src="http://www.domain2.com/b.html"
  style="display:none;"
></iframe>
```

```js
var iframe = document.getElementById('iframe')
iframe.onload = function () {
  var data = {
    name: 'aym'
  }
  // 向domain2传送跨域数据
  iframe.contentWindow.postMessage(
    JSON.stringify(data),
    'http://www.domain2.com'
  )
}

// 接受domain2返回数据
window.addEventListener(
  'message',
  function (e) {
    alert('data from domain2 ---> ' + e.data)
  },
  false
)
```

2.）b.html：(http://www.domain2.com/b.html)

```js
// 接收domain1的数据
window.addEventListener(
  'message',
  function (e) {
    alert('data from domain1 ---> ' + e.data)

    var data = JSON.parse(e.data)
    if (data) {
      data.number = 16

      // 处理后再发回domain1
      window.parent.postMessage(JSON.stringify(data), 'http://www.domain1.com')
    }
  },
  false
)
```

## nginx 代理跨域

1、 nginx 配置解决 iconfont 跨域

浏览器跨域访问 js、css、img 等常规静态资源被同源策略许可，但 iconfont 字体文件(eot|otf|ttf|woff|svg)例外，此时可在 nginx 的静态资源服务器中加入以下配置。

location / {
add_header Access-Control-Allow-Origin \*;
}

2、 nginx 反向代理接口跨域

跨域原理： 同源策略是浏览器的安全策略，不是 HTTP 协议的一部分。服务器端调用 HTTP 接口只是使用 HTTP 协议，不会执行 JS 脚本，不需要同源策略，也就不存在跨越问题。

实现思路：通过 nginx 配置一个代理服务器（域名与 domain1 相同，端口不同）做跳板机，反向代理访问 domain2 接口，并且可以顺便修改 cookie 中 domain 信息，方便当前域 cookie 写入，实现跨域登录。

nginx 具体配置：

```text
#proxy 服务器
server {
listen 81;
server_name www.domain1.com;

location / {
proxy_pass http://www.domain2.com:8080; #反向代理
proxy_cookie_domain www.domain2.com www.domain1.com; #修改 cookie 里域名
index index.html index.htm;

    # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用
    add_header Access-Control-Allow-Origin http://www.domain1.com;  #当前端只跨域不带cookie时，可为*
    add_header Access-Control-Allow-Credentials true;

}
}
```

1.)前端代码示例：

```js
var xhr = new XMLHttpRequest()

// 前端开关：浏览器是否读写 cookie
xhr.withCredentials = true

// 访问 nginx 中的代理服务器
xhr.open('get', 'http://www.domain1.com:81/?user=admin', true)
xhr.send()
```

2.) Nodejs 后台示例：

```js
var http = require('http')
var server = http.createServer()
var qs = require('querystring')

server.on('request', function (req, res) {
  var params = qs.parse(req.url.substring(2))

  // 向前台写cookie
  res.writeHead(200, {
    'Set-Cookie': 'l=a123456;Path=/;Domain=www.domain2.com;HttpOnly' // HttpOnly:脚本无法读取
  })

  res.write(JSON.stringify(params))
  res.end()
})

server.listen('8080')
console.log('Server is running at port 8080...')
```

## Nodejs 中间件代理跨域

node 中间件实现跨域代理，原理大致与 nginx 相同，都是通过启一个代理服务器，实现数据的转发。

1、 非 vue 框架的跨域（2 次跨域）

利用 node + express + http-proxy-middleware 搭建一个 proxy 服务器。

1.）前端代码示例：

```js
var xhr = new XMLHttpRequest();

// 前端开关：浏览器是否读写 cookie
xhr.withCredentials = true;

// 访问 http-proxy-middleware 代理服务器
xhr.open('get', 'http://www.domain1.com:3000/login?user=admin', true);
xhr.send(); 2.）中间件服务器：

var express = require('express');
var proxy = require('http-proxy-middleware');
var app = express();

app.use('/', proxy({
// 代理跨域目标接口
target: 'http://www.domain2.com:8080',
changeOrigin: true,

    // 修改响应头信息，实现跨域并允许带cookie
    onProxyRes: function(proxyRes, req, res) {
        res.header('Access-Control-Allow-Origin', 'http://www.domain1.com');
        res.header('Access-Control-Allow-Credentials', 'true');
    },

    // 修改响应信息中的cookie域名
    cookieDomainRewrite: 'www.domain1.com'  // 可以为false，表示不修改

}));

app.listen(3000);
console.log('Proxy server is listen at port 3000...'); 3.）Nodejs 后台同（六：nginx）
```

2、 vue 框架的跨域（1 次跨域）

利用 node + webpack + webpack-dev-server 代理接口跨域。在开发环境下，由于 vue 渲染服务和接口代理服务都是 webpack-dev-server 同一个，所以页面与代理接口之间不再跨域，无须设置 headers 跨域信息了。

webpack.config.js 部分配置：

```js
module.exports = {
entry: {},
module: {},
...
devServer: {
historyApiFallback: true,
proxy: [{
context: '/login',
target: 'http://www.domain2.com:8080', // 代理跨域目标接口
changeOrigin: true,
cookieDomainRewrite: 'www.domain1.com' // 可以为 false，表示不修改
}],
noInfo: true
}
}
```

## WebSocket 协议跨域

WebSocket protocol 是 HTML5 一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是 server push 技术的一种很好的实现。
原生 WebSocket API 使用起来不太方便，我们使用 Socket.io，它很好地封装了 webSocket 接口，提供了更简单、灵活的接口，也对不支持 webSocket 的浏览器提供了向下兼容。

1.）前端代码：

```html
<div>user input：<input type="text" /></div>
<script src="./socket.io.js"></script>
<script>
  var socket = io('http://www.domain2.com:8080')

  // 连接成功处理
  socket.on('connect', function () {
    // 监听服务端消息
    socket.on('message', function (msg) {
      console.log('data from server: ---> ' + msg)
    })

    // 监听服务端关闭
    socket.on('disconnect', function () {
      console.log('Server socket has closed.')
    })
  })

  document.getElementsByTagName('input')[0].onblur = function () {
    socket.send(this.value)
  }
</script>
```

2.）Nodejs socket 后台：

```js
var http = require('http')
var socket = require('socket.io')

// 启 http 服务
var server = http.createServer(function (req, res) {
  res.writeHead(200, {
    'Content-type': 'text/html'
  })
  res.end()
})

server.listen('8080')
console.log('Server is running at port 8080...')

// 监听 socket 连接
socket.listen(server).on('connection', function (client) {
  // 接收信息
  client.on('message', function (msg) {
    client.send('hello：' + msg)
    console.log('data from client: ---> ' + msg)
  })

  // 断开处理
  client.on('disconnect', function () {
    console.log('Client socket has closed.')
  })
})
```

## 参考

[九种跨域方式实现原理（完整版）](https://juejin.im/post/5c23993de51d457b8c1f4ee1)
