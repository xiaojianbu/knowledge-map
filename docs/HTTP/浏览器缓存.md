# 浏览器缓存

重用已获取的资源，减少延迟与网络阻塞，进而减少显示某个资源所用的时间，借助 HTTP 缓存，Web 站点变得更具有响应性。

## 缓存的一些应用场景

每次都加载某个同样的静态文件 => 浪费带宽，重复请求 => 让浏览器使用本地缓存（协商缓存，返回 304）

浏览器缓存分为强缓存和协商缓存。当客户端请求某个资源时，获取缓存的流程如下：

先根据这个资源的一些 http header 判断它是否命中强缓存，如果命中，则直接从本地获取缓存资源，不会发请求到服务器；

当强缓存没有命中时，客户端会发送请求到服务器，服务器通过另一些 request header 验证这个资源是否命中协商缓存，称为 http 再验证，如果命中，服务器将请求返回，但不返回资源，而是告诉客户端直接从缓存中获取，客户端收到返回后就会从缓存中获取资源；

强缓存和协商缓存共同之处在于，如果命中缓存，服务器都不会返回资源；

区别是，强缓存不对发送请求到服务器，但协商缓存会。

当协商缓存也没命中时，服务器就会将资源发送回客户端。

当 ctrl+f5 强制刷新网页时，直接从服务器加载，跳过强缓存和协商缓存；

为什么使用 ctrl+f5 和启用开发者面板中 Disable cache 选项后还会存在读取缓存的现象？

ctrl+f5 只不过能够管控 link、script、img、frame 等 dom 标签，还有样式中 background:url()、@font-face()等文件外链阻止它们去访问缓存,对于 AJAX 请求无能为力。

而 Disable cache 在每次请求之前，直接将清空了相应缓存，从根源阻止了浏览器的缓存相关策略，所以这时 AJAX 请求也不能使用缓存了。

当 f5 刷新网页时，跳过强缓存，但是会检查协商缓存（ chrome 刷新的时候，会返回 200 from cache）；

执行过程是：

第一次浏览器发送请求给服务器时，此时浏览器还没有本地缓存副本，服务器返回资源给浏览器，响应码是 200 OK，浏览器收到资源后，把资源和对应的响应头一起缓存下来。

第二次浏览器准备发送请求给服务器时候，浏览器会先检查上一次服务端返回的响应头信息中的 Cache-Control，它的值是一个相对值，单位为秒，表示资源在客户端缓存的最大有效期，过期时间为第一次请求的时间减去 Cache-Control 的值，过期时间跟当前的请求时间比较，如果本地缓存资源没过期，那么命中缓存，不再请求服务器。

如果没有命中，浏览器就会把请求发送给服务器，进入缓存协商阶段。

## 强缓存、协商缓存

1、基本原理

1）浏览器在加载资源时，根据请求头的 expires 和 cache-control 判断是否命中强缓存，是则直接从缓存读取资源，不会发请求到服务器。

2）如果没有命中强缓存，浏览器一定会发送一个请求到服务器，通过 last-modified 和 etag 验证资源是否命中协商缓存，如果命中，服务器会将这个请求返回，但是不会返回这个资源的数据，依然是从缓存中读取资源

3）如果前面两者都没有命中，直接从服务器加载资源

2、相同点

如果命中，都是从客户端缓存中加载资源，而不是从服务器加载资源数据；

3、不同点

强制缓存不需要访问服务器，返回结果是 200，协商缓存需要访问服务器，如果命中缓存的话，返回结果是 304。

## 强缓存：

Expires（该字段是 http1.0 时的规范，值为一个绝对时间的 GMT 格式的时间字符串，代表缓存资源的过期时间）

Cache-Control:max-age（该字段是 http1.1 的规范，强缓存利用其 max-age 值来判断缓存资源的最大生命周期，它的值单位为秒）

## 协商缓存：

Last-Modified（值为资源最后更新时间，随服务器 response 返回）

If-Modified-Since（通过比较两个时间来判断资源在两次请求期间是否有过修改，如果没有修改，则命中协商缓存）

ETag（表示资源内容的唯一标识，随服务器 response 返回）

If-None-Match（服务器通过比较请求头部的 If-None-Match 与当前资源的 ETag 是否一致来判断资源是否在两次请求之间有过修改，如果没有修改，则命中协商缓存）

## 清理网站缓存的几种方法

meta 方法

```html
//不缓存
<meta http-equiv="pragma" content="no-cache" />
<meta http-equiv="Cache-Control" content="no-cache, must-revalidate" />
<meta http-equiv="expires" content="0" />
```

用 AJAX 请求服务器最新文件，并加上请求头 If-Modified-Since 和 Cache-Control,如下:

```js
xmlHttp.setRequestHeader('If-Modified-Since', '0')
xmlHttp.setRequestHeader('Cache-Control', 'no-cache')
```

## 参考

[浏览器缓存](https://segmentfault.com/a/1190000008377508)

[浅谈 HTTP 缓存](http://zhanglun.xyz/2019/03/09/%E6%B5%85%E8%B0%88-HTTP-%E7%BC%93%E5%AD%98/)

[面试精选之 http 缓存](https://juejin.im/post/5b3c87386fb9a04f9a5cb037)

[前端缓存最佳实践](https://juejin.im/post/5c136bd16fb9a049d37efc47)

[HTTP 缓存控制小结](https://imweb.io/topic/5795dcb6fb312541492eda8c)
