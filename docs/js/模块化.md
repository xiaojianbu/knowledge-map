# 模块化

## 好处

使用模块化开发 JavaScript 应用程序主要有以下三种好处：

1. 提升维护性（Maintainability）
2. 命名空间（Namespacing）
3. 提供可重用性（Reusability）

## ES6 之前

以前的 Javascript 并没有模块体系，但是实际开发中，为了更高效的开发，我们需要模块化编程开发，也就产生了几类模块化标准。

### CommonJS（服务器端）

一个文件就是一个模块，每个模块都是单独的作用域，除非定义为 global 对象的属性。

输出模块 module.exports 对象

加载模块使用 require 方法

同步读取模块，适合 nodejs，由于网络的原因，并不适合浏览器端（异步加载）

#### 浏览器端面对的问题

多个文件的依赖关系，被依赖的文件需要在依赖他的文件之前加载到浏览器，
js加载时，浏览器会停止页面的渲染，加载的文件越多，页面失去相应的时间越长。

### AMD（异步模块定义）+ Require.js

其原理是异步加载模块，模块的加载不影响其后面语句的运行。所有依赖这个模块的语句都会添加进一个回调函数中，等到模块加载完成，回调函数就会执行。

require([module], callback) 读取模块

require.config 配置别名，使用例子：

```js
//别名配置
requirejs.config({
    paths: {
        jquery: 'jquery.min' //可以省略.js
    }
});
```

```js
//引入模块，用变量$表示jquery模块
requirejs(['jquery'], function ($) {
    $('body').css('background-color','red');
});
```

define(id?, dependencies?, factory) 定义模块

id：模块名

dependencies：当前模块依赖的模块

factory：工厂方法，一般直接返回一个对象

```js
define('math',['jquery'], function ($) {//引入jQuery模块
    return {
        add: function(x,y){
            return x + y;
        }
    };
});
```

### CMD（通用模块定义）+ SeaJS

CMD 和 AMD 解决的问题一样，不过是模块定义方式、模块加载的时机不同

SeaJS 示例：

```js
// 定义模块  myModule.js
define(function(require, exports, module) {
  var $ = require('jquery.js')
  $('div').addClass('active');
  exports.data = 1;
});
```

```js
// 加载模块
seajs.use(['myModule.js'], function(my){
    var star= my.data;
    console.log(star);  //1
});
```

### CMD & AMD间的区别

AMD 是 RequireJS 在推广过程中对模块定义的规范化产出。

CMD 是 SeaJS 在推广过程中对模块定义的规范化产出。

CMD 推崇**依赖就近**，AMD 推崇**依赖前置**。AMD 依赖前置，在定义模块时就声明其所要依赖的模块;CMD 是按需加载依赖，在用到那个模块再去 require。看代码：

```js
// CMD
define(function(require, exports, module) {
  var a = require('./a)
  a.doSomeThing()

  var b = require('./b')
  b.doSomeThing()
})

// AMD
define(['./a', './b'], function(a,b) {
  a.doSomeThing()
  b.doSomeThing()
})
```

## ES6 之后

模块可以是函数、数据、类，需要指定导出的模块名，才能被其他模块访问。

给数据、函数、类添加一个 export，就能导出模块。

在另外的 js 文件中，我们可以引用上面定义的模块。使用 import 关键字，导入分 2 种情况，一种是导入指定的模块，另外一种是导入全部模块。

```js
import fs from 'fs'
import {default as fs} from 'fs'
import * as fs from 'fs'
import {readFile} from 'fs'
import {readFile as read} from 'fs'
import fs, {readFile} from 'fs'

export default fs
export const fs
export function readFile
export {readFile, read}
export * from 'fs'
```

### CommonJS 中的 require/exports 和 ES6 中的 import/export 区别？

CommonJS 模块的重要特性是加载时执行，即脚本代码在 require 的时候，就会全部执行。一旦出现某个模块被”循环加载”，就只输出已经执行的部分，还未执行的部分不会输出。

ES6 模块是动态引用，如果使用 import 从一个模块加载变量，那些变量不会被缓存，而是成为一个指向被加载模块的引用，需要开发者自己保证，真正取值的时候能够取到值。
import/export 最终都是编译为 require/exports 来执行的。

CommonJS 规范规定，每个模块内部，module 变量代表当前模块。这个变量是一个对象，它的 exports 属性（即 module.exports ）是对外的接口。加载某个模块，其实是加载该模块的 module.exports 属性。

export 命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系。

## 参考文章

[require，import区别？](https://www.zhihu.com/question/56820346/answer/150724784)  

[JavaScript 模块化七日谈](http://huangxuan.me/2015/07/09/js-module-7day/)

[JavaScript Modules: A Beginner’s Guide](https://medium.freecodecamp.org/javascript-modules-a-beginner-s-guide-783f7d7a5fcc)
