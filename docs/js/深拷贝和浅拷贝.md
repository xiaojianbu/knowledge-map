# 深拷贝和浅拷贝

```js
/**
 * deep clone
 * @param  {[type]} parent object 需要进行克隆的对象
 * @return {[type]}        深克隆后的对象
 */
const clone = parent => {
  // 维护两个储存循环引用的数组
  const parents = []
  const children = []

  const _clone = parent => {
    if (parent === null) return null
    if (typeof parent !== 'object') return parent

    let child, proto

    if (isType(parent, 'Array')) {
      // 对数组做特殊处理
      child = []
    } else if (isType(parent, 'RegExp')) {
      // 对正则对象做特殊处理
      child = new RegExp(parent.source, getRegExp(parent))
      if (parent.lastIndex) child.lastIndex = parent.lastIndex
    } else if (isType(parent, 'Date')) {
      // 对Date对象做特殊处理
      child = new Date(parent.getTime())
    } else {
      // 处理对象原型
      proto = Object.getPrototypeOf(parent)
      // 利用Object.create切断原型链
      child = Object.create(proto)
    }

    // 处理循环引用
    const index = parents.indexOf(parent)

    if (index != -1) {
      // 如果父数组存在本对象,说明之前已经被引用过,直接返回此对象
      return children[index]
    }
    parents.push(parent)
    children.push(child)

    for (let i in parent) {
      // 递归
      child[i] = _clone(parent[i])
    }

    return child
  }
  return _clone(parent)
}
```

```js
function deepClone(obj) {
  var _toString = Object.prototype.toString

  // null, undefined, non-object, function
  if (!obj || typeof obj !== 'object') {
    return obj
  }

  // DOM Node
  if (obj.nodeType && 'cloneNode' in obj) {
    return obj.cloneNode(true)
  }

  // Date
  if (_toString.call(obj) === '[object Date]') {
    return new Date(obj.getTime())
  }

  // RegExp
  if (_toString.call(obj) === '[object RegExp]') {
    var flags = []
    if (obj.global) {
      flags.push('g')
    }
    if (obj.multiline) {
      flags.push('m')
    }
    if (obj.ignoreCase) {
      flags.push('i')
    }

    return new RegExp(obj.source, flags.join(''))
  }

  var result = Array.isArray(obj)
    ? []
    : obj.constructor
    ? new obj.constructor()
    : {}

  for (var key in obj) {
    result[key] = deepClone(obj[key])
  }

  return result
}

function A() {
  this.a = a
}

var a = {
  name: 'qiu',
  birth: new Date(),
  pattern: /qiu/gim,
  container: document.body,
  hobbys: ['book', new Date(), /aaa/gim, 111]
}

var c = new A()
var b = deepClone(c)
console.log(c.a === b.a)
console.log(c, b)
```

```js
 function shallowClone (source){
    if(!source || typeof source != 'object'){
        throw new Error ('error');
    }
    var targetObj = source.constructor === Array ? [] : {};
    for(var keys in source) {
        if(source.hasOwnProperty(keys)){
            targetObj[keys] = source[keys];
        }
    }
    return targetObj；
}

Object.assign
```

```js
function deepCopy(obj) {
  //判断是否是简单数据类型，
  if (typeof obj == 'object') {
    //复杂数据类型
    var result = obj.constructor == Array ? [] : {}
    for (let i in obj) {
      result[i] = typeof obj[i] == 'object' ? deepCopy(obj[i]) : obj[i]
    }
  } else {
    //简单数据类型 直接 == 赋值
    var result = obj
  }
  return result
}
```

![JS深拷贝和浅拷贝](https://raw.githubusercontent.com/xiaojianbu/markdownPicture/master/JS%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/JS%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D.png)

首先深复制和浅复制只针对像 Object, Array 这样的复杂对象的。简单来说，浅复制只复制一层对象的属性，而深复制则递归复制了所有层级。

深拷贝：将 B 对象拷贝到 A 对象中，包括 B 里面的子对象，

浅拷贝：将 B 对象拷贝到 A 对象中，但不包括 B 里面的子对象

深复制和浅复制的主要区别在于其在内存中的存储类型不同。

- 栈：为自动分配的内存空间；
- 堆：动态分配的内存，大小不定也不会自动释放。

在 JS 中基本数据类型存放在栈中；引用类型存放在堆中。

引用类型（object）是存放在堆内存中的，变量实际上是一个存放在栈内存的指针，这个指针指向堆内存中的地址。每个空间大小不一样，要根据情况开进行特定的分配。

## 传值与传址

进行赋值操作的时候，基本数据类型的赋值（=）是在内存中新开辟一段栈内存，然后再把再将值赋值到新的栈中。

引用类型的赋值是对象保存在栈中的地址的赋值，这样的话两个变量就指向同一个对象，因此两者之间操作互相有影响。

## 赋值（=）与浅复制的区别

```js
let obj1 = {
  name: 'zhangsan',
  age: '18',
  language: [1, [2, 3], [4, 5]]
}

let obj2 = obj1

//     let obj3 = shallowCopy(obj1);
//     function shallowCopy(src) {
//         let dst = {};
//         for (let prop in src) {
//             if (src.hasOwnProperty(prop)) {
//                 dst[prop] = src[prop];
//             }
//         }
//         return dst;
//     }
let obj3 = Object.assign({}, obj1)

obj2.name = 'lisi'
obj3.age = '20'

obj2.language[1] = ['二', '三']
obj3.language[2] = ['四', '五']

console.log(obj1)
//obj1 = {
//    'name' : 'lisi',
//    'age' :  '18',
//    'language' : [1,["二","三"],["四","五"]],
//}

console.log(obj2)
//obj2 = {
//    'name' : 'lisi',
//    'age' :  '18',
//    'language' : [1,["二","三"],["四","五"]],
//}

console.log(obj3)
//obj3 = {
//    'name' : 'zhangsan',
//    'age' :  '20',
//    'language' : [1,["二","三"],["四","五"]],
//}
```

- obj1：原始数据
- obj2：赋值操作得到
- obj3：浅拷贝得到

| --     | 和原数据是否指向同一对象 | 第一层数据为基本数据类型 | 原数据中包含子对象       |
| ------ | ------------------------ | ------------------------ | ------------------------ |
| 赋值   | 是                       | 改变会使原数据一同改变   | 改变会使原数据一同改变   |
| 浅拷贝 | 否                       | 改变不会使原数据一同改变 | 改变会使原数据一同改变   |
| 深拷贝 | 否                       | 改变不会使原数据一同改变 | 改变不会使原数据一同改变 |

## 深拷贝的一些实现

### 一般递归遍历实现

```js
function clone(obj) {
  let copy

  // Handle the 3 simple types, and null or undefined
  if (null === obj || 'object' !== typeof obj) {
    return obj
  }

  // Handle Date
  if (obj instanceof Date) {
    copy = new Date()
    copy.setTime(obj.getTime())
    return copy
  }

  // Handle Array
  if (obj instanceof Array) {
    copy = []
    for (let i = 0, len = obj.length; i < len; i++) {
      copy[i] = clone(obj[i])
    }
    return copy
  }

  // Handle Object
  if (obj instanceof Object) {
    copy = {}
    for (let attr in obj) {
      if (obj.hasOwnProperty(attr)) {
        copy[attr] = clone(obj[attr])
      }
    }
    return copy
  }
  throw new Error("Unable to copy obj! Its type isn't supported.")
}
```

### Array 的 slice 和 concat 方法

Array 的 slice 和 concat 方法不修改原数组，只会返回一个浅复制了原数组中的元素的一个新数组。

看起来像是深拷贝。而实际上它是浅拷贝。原数组的元素会按照下述规则拷贝：

- 如果该元素是个对象引用 （不是实际的对象），slice 会拷贝这个对象引用到新的数组里。两个对象引用都引用了同一个对象。如果被引用的对象发生改变，则新的和原来的数组中的这个元素也会发生改变。

- 对于字符串、数字及布尔值来说（不是 String、Number 或者 Boolean 对象），slice 会拷贝这些值到新的数组里。在别的数组里修改这些字符串或数字或是布尔值，将不会影响另一个数组。

如果向两个数组任一中添加了新元素，则另一个不会受到影响。例子如下

```js
let array = [1, 2, 3]
let array_shallow = array
let array_concat = array.concat()
let array_slice = array.slice(0)

console.log(array === array_shallow)
//true
console.log(array === array_slice)
//false，“看起来”像深拷贝
console.log(array === array_concat)
//false，“看起来”像深拷贝
```

concat 和 slice 返回的不同的数组实例

下面的例子中可以看出 Array 的 concat 和 slice 并不是真正的深复制，数组中的对象元素(Object,Array 等)只是复制了引用。

```js
let array = [
  1,
  [1, 2, 3],
  {
    name: 'array'
  }
]

let array_concat = array.concat()
let array_slice = array.slice(0)

array_concat[1][0] = 5
// 改变array_concat中数组元素的值
console.log(array[1])
// [5,2,3]
console.log(array_slice[1])
// [5,2,3]
array_slice[2].name = 'array_slice'
// 改变array_slice中对象元素的值
console.log(array[2].name)
// array_slice
console.log(array_concat[2].name)
// array_slice
```

### JSON 对象的 parse 和 stringify

JSON 对象 parse 方法可以将 JSON 字符串反序列化成 JS 对象，stringify 方法可以将 JS 对象序列化成 JSON 字符串，借助这两个方法，也可以实现对象的深拷贝。

这种方法使用较为简单，可以满足基本的深拷贝需求，而且能够处理 JSON 格式能表示的所有数据类型，但是对于正则表达式类型、函数类型等无法进行深拷贝(而且会直接丢失相应的值)。还有一点不好的地方是它会抛弃对象的 constructor。也就是深拷贝之后，不管这个对象原来的构造函数是什么，在深拷贝之后都会变成 Object。同时如果对象中存在循环引用的情况也无法正确处理。

```js
//例1
var source = { name: 'source', child: { name: 'child' } }
var target = JSON.parse(JSON.stringify(source))
target.name = 'target' //改变target的name属性
console.log(source.name) //source
console.log(target.name) //target
target.child.name = 'target child' //改变target的child
console.log(source.child.name) //child
console.log(target.child.name) //target child
//例2
var source = {
  name: function() {
    console.log(1)
  },
  child: { name: 'child' }
}
var target = JSON.parse(JSON.stringify(source))
console.log(target.name) //undefined
//例3
var source = {
  name: function() {
    console.log(1)
  },
  child: new RegExp('e')
}
var target = JSON.parse(JSON.stringify(source))
console.log(target.name) //undefined
console.log(target.child) //Object {}
```

### Zepto 中深拷贝代码

```js
// 内部方法：用户合并一个或多个对象到第一个对象
// 参数；
// target 目标对象 对象都合并到target里
// source 合并对象
// deep 是否执行深度合并

function extend(target, source, deep) {
  for (const key in source) {
    if (deep && (isPlainObject(source[key]) || isArray(source[key]))) {
      // source[key] 是对象，而 target[key] 不是对象， 则 target[key] = {} 初始化一下，否则递归会出错的
      if (isPlainObject(source[key]) && !isPlainObject(target[key])) {
        target[key] = {}
      }
      // source[key] 是数组，而 target[key] 不是数组，则 target[key] = [] 初始化一下，否则递归会出错的
      if (isArray(source[key]) && !isArray(target[key])) {
        target[key] = []
      }
      // 执行递归
      extend(target[key], source[key], deep)
    } else if (source[key] !== undefined) {
      // 不满足以上条件，说明 source[key] 是一般的值类型，直接赋值给 target 就是了
      target[key] = source[key]
    }
  }
}
```

### jQuery.extend()方法源码实现

```js
jQuery.extend = jQuery.fn.extend = function() {
  //给jQuery对象和jQuery原型对象都添加了extend扩展方法
  var options,
    name,
    src,
    copy,
    copyIsArray,
    clone,
    target = arguments[0] || {},
    i = 1,
    length = arguments.length,
    deep = false
  //以上其中的变量：options是一个缓存变量，用来缓存arguments[i]，name是用来接收将要被扩展对象的key，src改变之前target对象上每个key对应的value。
  //copy传入对象上每个key对应的value，copyIsArray判定copy是否为一个数组，clone深拷贝中用来临时存对象或数组的src。

  // 处理深拷贝的情况
  if (typeof target === 'boolean') {
    deep = target
    target = arguments[1] || {}
    //跳过布尔值和目标
    i++
  }

  // 控制当target不是object或者function的情况
  if (typeof target !== 'object' && !jQuery.isFunction(target)) {
    target = {}
  }

  // 当参数列表长度等于i的时候，扩展jQuery对象自身。
  if (length === i) {
    target = this
    --i
  }
  for (; i < length; i++) {
    if ((options = arguments[i]) != null) {
      // 扩展基础对象
      for (name in options) {
        src = target[name]
        copy = options[name]

        // 防止永无止境的循环，这里举个例子，
        // 如 var a = {name : b};
        // var b = {name : a}
        // var c = $.extend(a, b);
        // console.log(c);
        // 如果没有这个判断变成可以无限展开的对象
        // 加上这句判断结果是 {name: undefined}
        if (target === copy) {
          continue
        }
        if (
          deep &&
          copy &&
          (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)))
        ) {
          if (copyIsArray) {
            copyIsArray = false
            clone = src && jQuery.isArray(src) ? src : [] // 如果src存在且是数组的话就让clone副本等于src否则等于空数组。
          } else {
            clone = src && jQuery.isPlainObject(src) ? src : {} // 如果src存在且是对象的话就让clone副本等于src否则等于空数组。
          }
          // 递归拷贝
          target[name] = jQuery.extend(deep, clone, copy)
        } else if (copy !== undefined) {
          target[name] = copy // 若原对象存在name属性，则直接覆盖掉；若不存在，则创建新的属性。
        }
      }
    }
  }
  // 返回修改的对象
  return target
}
```

### 循环拷贝

```js
// 仅对对象和数组进行深拷贝，其他类型，直接返回
function isClone(x) {
  const t = type(x)
  return t === 'object' || t === 'array'
}

function cloneLoop(x) {
  const t = type(x)

  let root = x

  if (t === 'array') {
    root = []
  } else if (t === 'object') {
    root = {}
  }

  // 循环数组
  const loopList = [
    {
      parent: root,
      key: undefined,
      data: x
    }
  ]

  while (loopList.length) {
    // 深度优先
    const node = loopList.pop()
    const parent = node.parent
    const key = node.key
    const data = node.data
    const tt = type(data)

    // 初始化赋值目标，key为undefined则拷贝到父元素，否则拷贝到子元素
    let res = parent
    if (typeof key !== 'undefined') {
      res = parent[key] = tt === 'array' ? [] : {}
    }

    if (tt === 'array') {
      for (let i = 0; i < data.length; i++) {
        // 避免一层死循环 a.b = a
        if (data[i] === data) {
          res[i] = res
        } else if (isClone(data[i])) {
          // 下一次循环
          loopList.push({
            parent: res,
            key: i,
            data: data[i]
          })
        } else {
          res[i] = data[i]
        }
      }
    } else if (tt === 'object') {
      for (let k in data) {
        if (hasOwnProp(data, k)) {
          // 避免一层死循环 a.b = a
          if (data[k] === data) {
            res[k] = res
          } else if (isClone(data[k])) {
            // 下一次循环
            loopList.push({
              parent: res,
              key: k,
              data: data[k]
            })
          } else {
            res[k] = data[k]
          }
        }
      }
    }
  }

  return root
}
```

## 参考资料

[js 深拷贝 vs 浅拷贝](https://juejin.im/post/59ac1c4ef265da248e75892b)
[javaScript 中浅拷贝和深拷贝的实现](https://github.com/wengjq/Blog/issues/3)

[面试官:请你实现一个深克隆](https://juejin.im/post/5abb55ee6fb9a028e33b7e0a)
