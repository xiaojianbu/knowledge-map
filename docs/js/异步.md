# 异步

JS 是单线程的语言

浏览器中的线程：

- 渲染引擎
- JS 引擎
- 定时触发器
- 事件触发
- 异步 HTTP 请求

渲染线程和 JS 引擎线程是不能同时进行的。渲染线程在执行任务的时候，JS 引擎线程会被挂起。

JS 引擎线程用来执行栈中的同步任务，当所有同步任务执行完毕后，栈被清空，然后读取消息队列中的一个待处理任务，并把相关回调函数压入栈中，单线程开始执行新的同步任务。

JS 引擎线程从消息队列中读取任务是不断循环的，每次栈被清空后，都会在消息队列中读取新的任务，如果没有新的任务，就会等待，直到有新的任务，这就叫事件循环。

JS 引擎线程空闲后，会先查看是否有事件可执行，接着再处理其他异步任务。

## 异步与单线程的关系

所谓单线程，是指负责解释并执行 JS 代码的线程只有一个，它维护一个消息队列，当前函数栈执行完成之后就去不断地取消息队列中的消息（回调）,取到了就执行。

JS 运行时，就负责给 JS 引擎线程发送消息。比如浏览器 DOM 事件发送一条鼠标点击的消息，那么 JS 引擎在执行完函数栈之后就会取到这条鼠标点击信息，执行消息（即回调）。

## 回调函数

```js
function fn1() {
  console.log('function 1')
}

function fn2() {
  setTimeout(() => {
    console.log('function 2')
  }, 500)
}

function fn3() {
  console.log('function 3')
}
```

其中 fn2 可以视作一个延迟了 500 毫秒执行的异步函数。现在希望可以依次执行 fn1，fn2，fn3。为了保证 fn3 在最后执行，我们可以把它作为 fn2 的回调函数：

```js
function fn2(f) {
  setTimeout(() => {
    console.log('function 2')
    f()
  }, 500)
}
fn2(fn3)
```

## 事件发布/订阅

以上一节的例子来说，fn1，fn2，fn3 都可以视作一个事件的发布者，只要执行它，就会发布一个事件。这个时候，我们可以通过一个事件的订阅者去批量订阅并处理这些事件，包括它们的先后顺序。

```js
class AsyncFunArr {
  constructor(...arr) {
    this.funcArr = [...arr]
  }

  next() {
    const fn = this.funcArr.shift()
    if (typeof fn === 'function') {
      fn()
    }
  }

  run() {
    this.next()
  }
}

const asyncFunArr = new AsyncFunArr(fn1, fn2, fn3)
```

然后在 fn1,fn2,fn3 内调用其 next()方法

```js
function fn1() {
  console.log('function 1')
  asyncFunArr.next()
}
function fn2() {
  setTimeout(() => {
    console.log('Function 2')
    asyncFunArr.next()
  }, 500)
}

function fn3() {
  console.log('Function 3')
  asyncFunArr.next()
}
```

## Promise

```js
function fn1() {
  console.log('function 1')
}
function fn2() {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      console.log('function 2')
      resolve()
    }, 500)
  })
}
function fn3() {
  console.log('function 3')
}
```

fn2 是一个返回 Promise 的异步函数,希望按顺序执行它们，只需要按以下方式即可：

```js
fn1()
fn2().then(() => {
  fn3()
})
```

## generator

```js
function fn1() {
  console.log('function 1')
}

function fn2() {
  setTimeout(() => {
    console.log('function 2')
    af.next()
  }, 500)
}

function fn3() {
  console.log('function 3')
}

function* asyncFunArr(...fn) {
  fn[0]()
  yield fn[1]()
  fn[2]()
}
const af = asyncFunArr(fn1, fn2, fn3)
af.next()
```

generator 函数 asyncFunArr()接受一个待执行函数列表 fn，异步函数将会通过 yield 来执行。在异步函数内，通过 af.next()激活 generator 函数的下一步操作。

## async/await

async / await 是一种更方便地完成异步调用的语法

https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/async_function

https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/await

async function 声明用于定义一个返回 AsyncFunction 对象的异步函数。异步函数是指通过事件循环异步执行的函数，它会通过一个隐式的 Promise 返回其结果。但是如果你的代码使用了异步函数，它的语法和结构会更像是标准的同步函数。

```js
function fn1() {
  console.log('function 1')
}
function fn2() {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      console.log('function 2)
      resolve()
    })
  }, 500)
}
function fn3() {
  console.log('function 3')
}

async function asyncFunArr() {
  fn1()
  await fn2()
  fn3()
}

asyncFunArr()
```

## 异步函数串行实现

```js
let tasks = [1, 2, 3, 4, 5]
tasks = tasks.map((i) => {
  return function (cb) {
    setTimeout(function () {
      console.log(i)
      cb()
    }, (Math.random() * 500) | 0)
  }
})

/**
 * @param {function []} tasks - function array
 * @param {function} cb - 执行完的回调
 */
function seq(tasks, cb) {
  tasks.reduceRight(function (cb, task) {
    return function () {
      return task(cb)
    }
  }, cb)()
}

seq(tasks, function () {
  console.log('all Done')
})
```

```js
// 现有 n 个异步任务，这 n 个异步任务是依次执行且下一个异步任务依赖上一个异步任务的结果作参数，问如何实现。
;(async () => {
  const sleep = (delay) => {
    return new Promise((resolve, reject) => {
      setTimeout((_) => resolve(), delay)
    })
  }

  const task = (i) => {
    return new Promise(async (resolve, reject) => {
      await sleep(500)
      console.log(`now is ${i}`)
      ++i
      resolve(i)
    })
  }

  let param = 0
  for (let i = 0; i < 4; i++) {
    param = await task(param)
  }
})()

const sleep = (delay) => {
  return new Promise((resolve, reject) => {
    setTimeout((_) => resolve(), delay)
  })
}

const task = (i) => {
  return new Promise(async (resolve, reject) => {
    await sleep(500)
    console.log(`now is ${i}`)
    ++i
    resolve(i)
  })
}

;[task, task, task, task].reduce(async (prev, task) => {
  const res = await prev
  return task(res)
}, 0)
```

## 如何返回来自异步调用的响应？

### 问题

I have a function foo which makes an AJAX request. How can I return the response from foo?

I tried returning the value from the success callback as well as assigning the response to a local variable inside the function and returning that one, but none of those ways actually return the response.

```js
function foo() {
  var result

  $.AJAX({
    url: '...',
    success: function (response) {
      result = response
      // return response; // <- I tried that one as well
    }
  })

  return result
}

var result = foo() // It always ends up being `undefined`.
```

### 高票回复

[how-do-i-return-the-response-from-an-asynchronous-call](https://stackoverflow.com/questions/14220321/how-do-i-return-the-response-from-an-asynchronous-call/14220323#14220323)

[why-is-my-variable-unaltered-after-i-modify-it-inside-of-a-function-asynchron](https://stackoverflow.com/questions/23667086/why-is-my-variable-unaltered-after-i-modify-it-inside-of-a-function-asynchron)

### 总结

获取不到的原因是当你执行完这个函数 foo 的时候，result 还没有获取到响应的结果。

当要获取一个异步中的返回值时，可以利用回调函数、promise、async/await。

## 参考来源

[谈一谈几种处理 JavaScript 异步操作的办法](https://segmentfault.com/a/1190000008489550)

[关于异步 function 串行的实现](https://segmentfault.com/a/1190000005590411)

[How do I return the response from an asynchronous call?](https://stackoverflow.com/questions/14220321/how-do-i-return-the-response-from-an-asynchronous-call/14220323#14220323)
