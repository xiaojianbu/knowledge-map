# 任务队列

```js
setTimeout(function() {
  console.log(4)
}, 0)
new Promise(function(resolve) {
  console.log(1)
  for (var i = 0; i < 10000; i++) {
    i == 9999 && resolve()
  }
  console.log(2)
}).then(function() {
  console.log(5)
})
console.log(3)
```

以上代码, 最终运行结果是 1,2,3,5,4. 并不是 1,2,3,4,5.

- 首先, new Promise 第一个回调函数内的语句同步执行, 因此控制台将顺序输出 1,2, 此处应无异议.
- console.log(3), 这里是同步执行, 因此接着将输出 3, 此处应无异议.
- 剩下便是 setTimeout 和 Promise 的 then 的博弈了, 同为异步事件, 为什么 then 后注册却先于 setTimeout 执行?

event loop 至少拥有如下两种队列:

- task queue, 也叫 macrotask queue, 指的是宏任务队列, 包括 rendering, script(页面脚本), 鼠标, 键盘, 网络请求等事件触发, setTimeout, setInterval, setImmediate(node)等等.

- microtask queue, 指的是微任务队列, 用于在浏览器重新渲染前执行, 包含 Promise, process.nextTick(node), Object.observe, MutationObserver 回调等.

浏览器(或宿主环境) 遵循队列先进先出原则, 依次遍历 macrotask queue 中的每一个 task, 不过每执行一个 macrotask, 并不是立即就执行下一个, 而是执行一遍 microtask queue 中的任务, 然后切换 GUI 线程重新渲染或垃圾回收等.

上述代码块可以看做是一个 macrotask, 对于其执行过程, 不妨作如下简化:

- 首先执行当前 macrotask, 将 setTimeout 回调以一个新的 task 形式, 加入到 macrotask queue 末尾.
- 当前 macrotask 继续执行, 创建一个新的 Promise, 同步执行其回调函数, 输出 1; for 循环 1w 次, 然后执行 resolve 方法, 将该 Promise 回调加入到 microtask queue 末尾, 循环结束, 接着输出 2.
- 当前 macrotask 继续执行, 输出 3. 至此, 当前 macrotask 执行完毕.
- 开始顺序执行 microtask queue 中的所有任务, 也包括刚刚加入到队列末尾 Promise 回调, 故输出 5. 至此, microtask queue 任务全部执行完毕, microtask queue 清空.
- 浏览器挂起 js 引擎, 可能切换至 GUI 线程或者执行垃圾回收等.
- 切换回 js 引擎, 继续从 macrotask queue 取出下一个 macrotask, 执行之, 然后再取出 microtask queue, 执行之, 后续所有的 macrotask 均如此重复. 自然, 也包括刚刚加入到队列末尾的 setTimeout 回调, 故输出 4.

事件回调优先级:

process.nextTick > promise.then > setTimeout ? setImmediate

## 来源

[Promise 的队列与 setTimeout 的队列有何关联？](https://www.zhihu.com/question/36972010)

[Promise 使用手册](https://juejin.im/post/58f41a13a0bb9f006aa1aab4)
