# 任务队列

```js
setTimeout(function() {
  console.log(4)
}, 0)
new Promise(function(resolve) {
  console.log(1)
  for (var i = 0; i < 10000; i++) {
    i == 9999 && resolve()
  }
  console.log(2)
}).then(function() {
  console.log(5)
})
console.log(3)
```

以上代码, 最终运行结果是 1,2,3,5,4. 并不是 1,2,3,4,5.

- 首先, new Promise 第一个回调函数内的语句同步执行, 因此控制台将顺序输出 1,2, 此处应无异议.
- console.log(3), 这里是同步执行, 因此接着将输出 3, 此处应无异议.
- 剩下便是 setTimeout 和 Promise 的 then 的博弈了, 同为异步事件, 为什么 then 后注册却先于 setTimeout 执行?

event loop 至少拥有如下两种队列:

- task queue, 也叫 macrotask queue, 指的是宏任务队列, 包括 rendering, script(页面脚本), 鼠标, 键盘, 网络请求等事件触发, setTimeout, setInterval, setImmediate(node)等等.

- microtask queue, 指的是微任务队列, 用于在浏览器重新渲染前执行, 包含 Promise, process.nextTick(node), Object.observe, MutationObserver 回调等.

浏览器(或宿主环境) 遵循队列先进先出原则, 依次遍历 macrotask queue 中的每一个 task, 不过每执行一个 macrotask, 并不是立即就执行下一个, 而是执行一遍 microtask queue 中的任务, 然后切换 GUI 线程重新渲染或垃圾回收等.

上述代码块可以看做是一个 macrotask, 对于其执行过程, 不妨作如下简化:

- 首先执行当前 macrotask, 将 setTimeout 回调以一个新的 task 形式, 加入到 macrotask queue 末尾.
- 当前 macrotask 继续执行, 创建一个新的 Promise, 同步执行其回调函数, 输出 1; for 循环 1w 次, 然后执行 resolve 方法, 将该 Promise 回调加入到 microtask queue 末尾, 循环结束, 接着输出 2.
- 当前 macrotask 继续执行, 输出 3. 至此, 当前 macrotask 执行完毕.
- 开始顺序执行 microtask queue 中的所有任务, 也包括刚刚加入到队列末尾 Promise 回调, 故输出 5. 至此, microtask queue 任务全部执行完毕, microtask queue 清空.
- 浏览器挂起 js 引擎, 可能切换至 GUI 线程或者执行垃圾回收等.
- 切换回 js 引擎, 继续从 macrotask queue 取出下一个 macrotask, 执行之, 然后再取出 microtask queue, 执行之, 后续所有的 macrotask 均如此重复. 自然, 也包括刚刚加入到队列末尾的 setTimeout 回调, 故输出 4.

事件回调优先级:

process.nextTick > promise.then > setTimeout ? setImmediate

```js
new Promise((resolve, reject) => {
  console.log('promise1')
  resolve()
})
  .then(() => {
    console.log('then11')
    new Promise((resolve, reject) => {
      console.log('promise2')
      resolve()
    })
      .then(() => {
        console.log('then21')
      })
      .then(() => {
        console.log('then23')
      })
  })
  .then(() => {
    console.log('then12')
  })
```

第一轮

- current task: promise1 是当之无愧的立即执行的一个函数，参考上一章节的 executor，立即执行输出[promise1]
- micro task queue: [promise1 的第一个 then]

第二轮

- current task: then1 执行中，立即输出了 then11 以及新 promise2 的 promise2
- micro task queue: [新 promise2 的 then 函数,以及 promise1 的第二个 then 函数]

第三轮

- current task: 新 promise2 的 then 函数输出 then21 和 promise1 的第二个 then 函数输出 then12。
- micro task queue: [新 promise2 的第二 then 函数]

第四轮

- current task: 新 promise2 的第二 then 函数输出 then23
- micro task queue: []

最终结果[promise1,then11,promise2,then21,then12,then23]

```js
new Promise((resolve, reject) => {
  console.log('promise1')
  resolve()
})
  .then(() => {
    console.log('then11')
    return new Promise((resolve, reject) => {
      console.log('promise2')
      resolve()
    })
      .then(() => {
        console.log('then21')
      })
      .then(() => {
        console.log('then23')
      })
  })
  .then(() => {
    console.log('then12')
  })
```

Promise 的第二个 then 相当于是挂在新 Promise 的最后一个 then 的返回值上。

## 在没有 Promise 的浏览器中，微任务这个队列是如何实现的呢？

如果是拥有 setImmediate 函数平台，则使用之，若没有则利用各种比如 nodejs 中的 process.nextTick，浏览器中支持 postMessage 的，或者是通过 create 一个 script 来实现微任务(microtask)。最终的最终，是使用 setTimeout，不过这个就和微任务无关了，promise 变成了宏任务的一员。

## 来源

[Promise 的队列与 setTimeout 的队列有何关联？](https://www.zhihu.com/question/36972010)

[Promise 使用手册](https://juejin.im/post/58f41a13a0bb9f006aa1aab4)

[Eventloop 不可怕，可怕的是遇上 Promise](https://juejin.im/post/5c9a43175188252d876e5903)

https://juejin.im/post/5bbee9d36fb9a05cff32388d
