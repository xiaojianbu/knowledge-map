# var、let 及 const 的区别

var、let 和 const 都可以用来声明变量

var 声明的变量是属于函数作用域的

let 和 const 声明的变量是属于块级作用域的

var 声明的变量具有自动提升的效果，在一个函数作用域任意地点声明的变量都等同于在函数作用域的开头声明，但是初始化是不被提升的。

let 会将变量提升到代码块的顶部，但是 let 和 const 声明的变量存在暂存死区（即只有在声明变量之后才可以使用变量），在变量声明之前去访问变量会导致**ReferenceError**。

暂存死区（Temporal dead zone）是指从代码块开始直到变量被声明之间的区域

const 定义完之后内容不可修改，但是内容所指向的地方可以进行修改。（不可变的是地址）

如果希望声明的变量不论是原始数据类型还是引用数据类型都是不可变的，可以利用 Object.freeze 方法实现：

```JavaScript
const deepFreeze = function(obj) {
  Object.freeze(obj)
  for (const key in obj) {
    if (typeof obj[key] === 'object') {
      deepFreeze(obj[key])
    }
  }
  return obj
}
```

const 和 Object.freeze()并不同，const 是防止变量重新分配，而 Object.freeze()是使对象具有不可变性。

let 和 const 不能重复声明：如果一个变量已经在作用域中定义了，然后在这个作用域中再使用 let 声明这个变量，会抛出一个异常。

每个 const 变量必须在声明时赋值

let 和 const 不同于 var 的另一个方面是它们在全局作用域的行为。当在全局作用域使用 var 时，这就创建了一个新的全局变量，它是全局对象（浏览器是 window 对象）的一个属性。意味着，可以意外地覆盖 window 对象上原生的方法和属性。

为什么 var 可以重复声明？

JavaScript 从来不会告诉你是否多次声明了同一个变量；遇到这种情况，它只会对后续的声明视而不见（不过，它会执行后续声明中的变量初始化）。参考《JavaScript 高级程序设计》第 7.3 章节

当我们执行代码时，我们可以简单的理解为新变量分配一块儿内存，命名为 a，并赋值为 2，但在运行的时候编译器与引擎还会进行两项额外的操作：判断变量是否已经声明：

- 首先编译器对代码进行分析拆解，从左至右遇见 var a，则编译器会询问作用域是否已经存在叫 a 的变量了，如果不存在，则招呼作用域声明一个新的变量 a，若已经存在，则忽略 var 继续向下编译，这时 a = 2 被编译成可执行的代码供引擎使用。
- 引擎遇见 a=2 时同样会询问在当前的作用域下是否有变量 a，若存在，则将 a 赋值为 2（由于第一步编译器忽略了重复声明的 var，且作用域中已经有 a，所以重复声明会发生值得覆盖而并不会报错）。若不存在，则顺着作用域链向上查找，若最终找到了变量 a 则将其赋值 2，若没有找到，则招呼作用域声明一个变量 a 并赋值为 2。
