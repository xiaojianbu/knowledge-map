# 柯里化

```js
const curry = (fn, len = fn.length, ...args) =>
  len <= args.length ? fn(...args) : curry.bind(null, fn, len, ...args)
// curry(Math.pow)(2)(10) -> 1024
// curry(Math.min, 3)(10)(50)(2) -> 2
```

https://www.zhangxinxu.com/wordpress/2013/02/js-currying/

http://www.cnblogs.com/hustskyking/archive/2013/04/09/uncurrying.html


# 柯里化

柯里化，是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。

在数学和计算机科学中，柯里化是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。

用闭包把参数保存起来，当参数的数量足够执行函数了，就开始执行函数

```js
let curry = function(fn) {
  let args = [].slice.call(arguments, 1)
  return function() {
    let newArgs = args.concat([].slice.call(arguments))
    return fn.apply(this, newArgs)
  }
}
```

```js
let sub_curry = function(fn) {
  let args = [].slice.call(arguments, 1)
  return function() {
    let newArgs = args.concat([].slice.call(arguments))
    return fn.apply(this, newArgs)
  }
}

let curry = function(fn, length = fn.length) {
  let slice = Array.prototype.slice
  return function() {
    if (arguments.length < length) {
      let combined = [fn].concat(slice.call(arguments))
      return curry(sub_curry.apply(this, combined), length - arguments.length)
    } else {
      return fn.apply(this, arguments)
    }
  }
}

var fn = curry(function(a, b, c) {
  return [a, b, c]
})

fn('a', 'b', 'c') // ["a", "b", "c"]
fn('a', 'b')('c') // ["a", "b", "c"]
fn('a')('b')('c') // ["a", "b", "c"]
fn('a')('b', 'c') // ["a", "b", "c"]
```

```js
var currying = function(fn) {
  // fn 指官员消化老婆的手段
  var args = [].slice.call(arguments, 1)
  // args 指的是那个合法老婆
  return function() {
    // 已经有的老婆和新搞定的老婆们合成一体，方便控制
    var newArgs = args.concat([].slice.call(arguments))
    // 这些老婆们用 fn 这个手段消化利用，完成韦小宝前辈的壮举并返回
    return fn.apply(null, newArgs)
  }
}

// 下为官员如何搞定7个老婆的测试
// 获得合法老婆
var getWife = currying(function() {
  var allWife = [].slice.call(arguments)
  // allwife 就是所有的老婆的，包括暗渡陈仓进来的老婆
  console.log(allWife.join(';'))
}, '合法老婆')

// 获得其他6个老婆
getWife('大老婆', '小老婆', '俏老婆', '刁蛮老婆', '乖老婆', '送上门老婆')
```
