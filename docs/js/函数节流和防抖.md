# 函数节流和防抖

## 函数节流

调节强制执行一段时间内可以调用函数的最大次数，如“每 100 毫秒最多执行一次”。

### lodash 实现

```js
/**
 * 频率控制 返回函数连续调用时，func 执行频率限定为 次 / wait
 *
 * @param  {function}   func      传入函数
 * @param  {number}     wait      表示时间窗口的间隔
 * @param  {object}     options   如果想忽略开始边界上的调用，传入{leading: false}。
 *                                如果想忽略结尾边界上的调用，传入{trailing: false}
 * @return {function}             返回客户调用函数
 */
_.throttle = function (func, wait, options) {
  var context, args, result
  var timeout = null
  // 上次执行时间点
  var previous = 0
  if (!options) options = {}
  // 延迟执行函数
  var later = function () {
    // 若设定了开始边界不执行选项，上次执行时间始终为0
    previous = options.leading === false ? 0 : _.now()
    timeout = null
    result = func.apply(context, args)
    if (!timeout) context = args = null
  }
  return function () {
    var now = _.now()
    // 首次执行时，如果设定了开始边界不执行选项，将上次执行时间设定为当前时间。
    if (!previous && options.leading === false) previous = now
    // 延迟执行时间间隔
    var remaining = wait - (now - previous)
    context = this
    args = arguments
    // 延迟时间间隔remaining小于等于0，表示上次执行至此所间隔时间已经超过一个时间窗口
    // remaining 大于时间窗口 wait，表示客户端系统时间被调整过
    if (remaining <= 0 || remaining > wait) {
      clearTimeout(timeout)
      timeout = null
      previous = now
      result = func.apply(context, args)
      if (!timeout) context = args = null
      //如果延迟执行不存在，且没有设定结尾边界不执行选项
    } else if (!timeout && options.trailing !== false) {
      timeout = setTimeout(later, remaining)
    }
    return result
  }
}
```

### 普通实现

```js
/**
 * @description: 节流函数：规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行
 * @param {Function} fn 要执行的函数
 * @param {Number} gapTime  单位时间
 * @param {*} ...arr 传递给fn的参数
 */
function throttle(fn, gapTime, ...arr) {
  let last = 0 // 上次执行时间 第一次马上执行
  return () => {
    let nowTime = Date.now() // 当前时间
    // 当前时间-上次执行的时间是否超过间隔时间 就执行回调
    if (nowTime - last > gapTime) {
      fn(...arr) // ...arr为fn的参数
      last = nowTime // 重置上次执行时间为当前时间 方便下次执行
    }
  }
}
```

### 应用场景

- DOM 元素的拖拽功能实现（mousemove）
- 计算鼠标移动的距离（mousemove）
- 搜索联想（keyup）
- 监听滚动事件判断是否到页面底部自动加载更多内容

### 例子

#### 元素拖拽的效果，可以在每次 move 事件中进行重绘 DOM

```js
//普通方案
$dragable.addEventListener('mousemove', () => {
  console.log('trigger')
})

// 函数节流的方案

/**
 *
 * @param fn {Function}   实际要执行的函数
 * @param delay {Number}  执行间隔，单位是毫秒（ms）
 *
 * @return {Function}     返回一个“节流”函数
 */
function throttle(fn, threshold = 250) {
  // 记录上次执行的时间
  let last
  // 定时器
  let timer
  // 返回的函数，每隔threshold 毫秒就执行一次fn函数
  return function () {
    // 保存函数调用时的上下文和参数，传递给 fn
    var context = this
    var args = arguments
    var now = +new Date()
    // 如果距离上次执行 fn 函数的时间小于 threshold，那么就放弃
    // 执行 fn，并重新计时
    if (last && now < last + threshold) {
      clearTimeout(timer)
      // 保证在当前时间区间结束后，再执行一次 fn
      timer = setTimeout(function () {
        last = now
        fn.apply(context, args)
      }, threshold)
      // 在时间区间的最开始和到达指定间隔的时候执行一次 fn
    } else {
      last = now
      fn.apply(context, args)
    }
  }
}

// ES6 版

function throttle(func, interval) {
  let identify = 0
  return (...args) => {
    if (identify) {
      return
    }
    identify = setTimeout(() => (identify = 0), interval)
    func.apply(this, args)
  }
}
```

每次回调执行以后，需要保存执行的函数的时间戳，为了计算以后的事件触发回调时与之前执行回调函数的时间戳的间隔，从而根据间隔判断要不要执行回调

## 函数去抖

在事件被触发 n 秒后再执行回调，如果在这 n 秒内又被触发，则重新计时。

### lodash 实现

```js
/**
 * 空闲控制 返回函数连续调用时，空闲时间必须大于或等于 wait，func 才会执行
 *
 * @param  {function} func        传入函数
 * @param  {number}   wait        表示时间窗口的间隔
 * @param  {boolean}  immediate   设置为ture时，调用触发于开始边界而不是结束边界
 * @return {function}             返回客户调用函数
 */
_.debounce = function (func, wait, immediate) {
  var timeout, args, context, timestamp, result

  var later = function () {
    // 据上一次触发时间间隔
    var last = _.now() - timestamp

    // 上次被包装函数被调用时间间隔last小于设定时间间隔wait
    if (last < wait && last > 0) {
      timeout = setTimeout(later, wait - last)
    } else {
      timeout = null
      // 如果设定为immediate===true，因为开始边界已经调用过了此处无需调用
      if (!immediate) {
        result = func.apply(context, args)
        if (!timeout) context = args = null
      }
    }
  }

  return function () {
    context = this
    args = arguments
    timestamp = _.now()
    var callNow = immediate && !timeout
    // 如果延时不存在，重新设定延时
    if (!timeout) timeout = setTimeout(later, wait)
    if (callNow) {
      result = func.apply(context, args)
      context = args = null
    }

    return result
  }
}
```

### 应用场景

- 窗口缩放，每次 resize/scroll 触发事件
- 文本输入的验证（连续输入文字后发送 AJAX 请求进行验证，验证一次就好）

### 例子

#### 监听窗口大小重绘的操作。

在用户拖拽窗口时，一直在改变窗口的大小，如果我们在 resize 事件中进行一些操作，消耗将是巨大的。而且大多数可能是无意义的执行，因为用户还处于拖拽的过程中。

可以使用 函数防抖 来优化相关的处理。

```js
// 普通方案
window.addEventListener('resize', () => {
  console.log('trigger)
})

// 函数防抖方案
let debounceIdentify = 0
window.addEventListener('resize', () => {
  debounceIdentify && clearTimeout(debounceIdentify)
  debounceIdentify = setTimeout(() => {
    console.log('trigger')
  }, 300)
})
```

在 resize 事件中，我们添加了一个 300 ms 的延迟执行逻辑。

并且在每次事件触发时，都会重新计时，这样可以确保函数的执行肯定是在距离上次 resize 事件被触发的 300 ms 后。

两次 resize 事件间隔小于 300 ms 的都被忽略了，这样就会节省很多无意义的事件触发。

#### 搜索联想

```js
function debounce(func, delay) {
  return function (args) {
    let _this = this
    let _args = args
    clearTimeout(func.id)
    func.id = setTimeout(function () {
      func.call(_this, _args)
    }, delay)
  }
}

function AJAX(value) {
  console.log('AJAX request' + value)
}

let debounceAJAX = debounce(AJAX, 1000)
let input = document.getElementById('search')

input.addEventListener('keyup', function (e) {
  debounceAJAX(e.target.value)
})
```

当停止并且指定间隔内没有输入的时候，才会执行相应的回调函数。

#### 表单的提交

在一些与用户的交互上，比如提交表单后，一般都会显示一个 loading 框来提示用户，用户提交的表单正在处理中。但是发送表单请求后就显示 loading 是一件很不友好的事情，因为请求可能在几十毫秒内就会得到响应。这样在用户看来就是页面中闪过一团黑色，所以可以在提交表单后添加一个延迟函数，在 XXX 秒后再显示 loading 框。这样在快速响应的场景下，用户是不会看到一闪而过的 loading 框，当然，一定要记得在接收到数据后去 clearTimeout

```js
let identify = setTimeout(showLoadingModal, 500)
axios('url').then((res) => {
  // doing something

  // clear timer
  clearTimeout(identify)
})
```

## 可视化解释

![debounce 和 throttle 可视化区别](https://raw.githubusercontent.com/xiaojianbu/markdownPicture/master/debounce%20%E5%92%8C%20throttle%20%E5%8F%AF%E8%A7%86%E5%8C%96%E5%8C%BA%E5%88%AB/debounce%20%E5%92%8C%20throttle%20%E5%8F%AF%E8%A7%86%E5%8C%96%E5%8C%BA%E5%88%AB.png)

## 特殊例子：防止重复发送 AJAX 请求

A. 独占型提交
只允许同时存在一次提交操作，并且直到本次提交完成才能进行下一次提交。

```js
module.submit = function () {
  if (this.promise_.state() === 'pending') {
    return
  }
  return (this.promise_ = $.post('./api/save'))
}
```

B. 贪婪型提交
无限制的提交，但是以最后一次操作为准；亦即需要尽快给出最后一次操作的反馈，而前面的操作结果并不重要。

```js
module.submit = function () {
  if (this.promise_.state() === 'pending') {
    this.promise_.abort()
  }
  // todo
}
```

C: 节制型提交
无论提交如何频繁，任意两次有效提交的间隔时间必定会大于或等于某一时间间隔；即以一定频率提交。

```js
module.submit = throttle(150, function () {
  // todo
})
```

如果客户发送每隔 100 毫秒发送过来 10 次请求，此模块将只接收其中 6 个（每个在时间线上距离为 150 毫秒）进行处理.

D. 懒惰型提交
任意两次提交的间隔时间，必须大于一个指定时间，才会促成有效提交；即不给休息不干活。

```js
module.submit = debounce(150, function () {
  // todo
})
```

## 实现

```js
// func是用户传入需要防抖的函数
// wait是等待时间
const debounce = (func, wait = 50) => {
  // 缓存一个定时器id
  let timer = 0
  // 这里返回的函数是每次用户实际调用的防抖函数
  // 如果已经设定过定时器了就清空上一次的定时器
  // 开始一个新的定时器，延迟执行用户传入的方法
  return function (...args) {
    if (timer) clearTimeout(timer)
    timer = setTimeout(() => {
      func.apply(this, args)
    }, wait)
  }
}
// 不难看出如果用户调用该函数的间隔小于wait的情况下，上一次的时间还未到就被清除了，并不会执行函数
```

```js
// 这个是用来获取当前时间戳的
function now() {
  return +new Date()
}
/**
 * 防抖函数，返回函数连续调用时，空闲时间必须大于或等于 wait，func 才会执行
 *
 * @param  {function} func        回调函数
 * @param  {number}   wait        表示时间窗口的间隔
 * @param  {boolean}  immediate   设置为ture时，是否立即调用函数
 * @return {function}             返回客户调用函数
 */
function debounce (func, wait = 50, immediate = true) {
  let timer, context, args

  // 延迟执行函数
  const later = () => setTimeout(() => {
    // 延迟函数执行完毕，清空缓存的定时器序号
    timer = null
    // 延迟执行的情况下，函数会在延迟函数中执行
    // 使用到之前缓存的参数和上下文
    if (!immediate) {
      func.apply(context, args)
      context = args = null
    }
  }, wait)

  // 这里返回的函数是每次实际调用的函数
  return function(...params) {
    // 如果没有创建延迟执行函数（later），就创建一个
    if (!timer) {
      timer = later()
      // 如果是立即执行，调用函数
      // 否则缓存参数和调用上下文
      if (immediate) {
        func.apply(this, params)
      } else {
        context = this
        args = params
      }
    // 如果已有延迟执行函数（later），调用的时候清除原来的并重新设定一个
    // 这样做延迟函数会重新计时
    } else {
      clearTimeout(timer)
      timer = later()
    }
  }
}


// 防抖动函数
function debounce(fn,wait=50,immediate) {
    let timer;
    return function() {
        if(immediate) {
            fn.apply(this,arguments)
        }
        if(timer) clearTimeout(timer)
        timer = setTimeout(()=> {
            fn.apply(this,arguments)
        },wait)
    }
}


function throttle(fn, wait) {
  let prev = new Date();
  return function() {
    const args = arguments;
    const now = new Date();
    if (now - prev > wait) {
      fn.apply(this, args);
      prev = new Date();
    }
  }
```

## 参考来源

[数组扁平化，柯里化，防抖，节流](https://github.com/sakila1012/blog/issues/17)

[怎样防止重复发送 AJAX 请求？](https://www.zhihu.com/question/19805411)
