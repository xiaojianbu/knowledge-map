# 继承与原型链

当谈到继承时，JavaScript 只有一种结构：对象。每个对象都有一个私有属性（[[Prototype]]），它指向它的原型对象（prototype）。该 prototype 对象又具有一个自己的 prototype，层层向上直到一个对象的原型为 null.根据定义，null 没有原型，并作为这个原型链中的最后一个环节。

实例的\_\_proto\_\_属性（原型）等于其构造函数的 prototype 属性。

## 基于原型链的继承

### 继承属性

当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象的原型的原型，依次层层向上搜索，直到找到匹配的属性或到达原型链的末尾。

### 继承方法

函数的继承与其他的属性继承没有差别。当继承的函数被调用时，this 指向的是当前继承的对象，而不是继承的函数所在的原型对象。

## 使用不同的方法来创建对象和生成原型链

### 语法结构创建的对象

```js
var o = { a: 1 }
// o 这个对象继承了 Object.prototype上面的所有属性
```

### 构造器创建的对象

在 JavaScript 中，构造器就是一个普通的函数。当使用 new 操作符来作用这个函数时，它就被称为构造函数。

```js
function Graph() {
  this.vertices = []
  this.edges = []
}

Graph.prototype = {
  addVertex: function(v) {
    this.vertices.push(v)
  }
}

let g = new Graph()
// g 是生成的对象，它的自身属性有 'vertices' 和 'edges'.
// 在 g 被实例化时，g.[[Prototype]]指向了Graph.prototype.
```

### Object.create 创建对象

调用这个方法创建一个新对象，新对象的原型就是调用 create 方法时传入的第一个参数。

```js
let a = { a: 1 }
// a ---> Object.prototype ---> null

let b = Object.create(a)
// b ---> a ---> Object.prototype ---> null
console.log(b.a) // 1 （继承而来）
```

Object.create 的 Polyfill

```js
if (typeof Object.create !== 'function') {
  Object.create = function(proto, propertiesObject) {
    if (typeof proto !== 'object' && typeof proto !== 'function') {
      throw new TypeError('Object prototype may only be an Object: ' + proto)
    } else if (proto === null) {
      throw new Error(
        "This browser's implementation of Object.create is a shim and doesn't support 'null' as the first argument."
      )
    }

    if (typeof propertiesObject != 'undefined') {
      throw new Error(
        "This browser's implementation of Object.create is a shim and doesn't support a second argument."
      )
    }

    function F() {}
    F.prototype = proto
    return new F()
  }
}
```

### class 关键字创建的对象

```js
class Polygon {
  constructor(height, width) {
    this.height = height
    this.width = width
  }
}

class Square extends Polygon {
  constructor(sideLength) {
    super(sideLength, sideLength)
  }
  get area() {
    return this.sideLength * this.sideLength
  }
  set sideLength(newLength) {
    this.height = newLength
    this.width = newLength
  }
}

let square = new Square(2)
```

## prototype 和 Object.getPrototypeOf

prototype 是一个拥有[[Construct]]内部方法的对象才有的属性。

例如函数，对象的方法，ES6 中的类。注意 ES6 中的箭头函数没有[[Construct]]方法，因此没有 prototype 这个属性,通过 Function.prototype.bind 方法构造出来的函数，它也没有 prototype 属性。

当执行：

```js
let o = new Foo()
```

JavaScript 实际执行的是:

```js
let o = new Object()
o.__proto__ = Foo.prototype
Foo.call(o)
```

1. 创建对象，设为 o;
2. 将 o 的\_\_proto\_\_指向构造函数的原型对象；
3. 将 o 作为 this 去调用构造函数，从而设置 o 的属性和方法并初始化。

\_\_proto\_\_和 prototype 的区别看图：

![__proto__和prototype](https://raw.githubusercontent.com/xiaojianbu/markdownPicture/master/%E5%82%BB%E5%82%BB%E5%88%86%E4%B8%8D%E6%B8%85%E7%9A%84__proto__%E4%B8%8Eprototype/proto.png)

另一张

![__proto__和prototype](https://raw.githubusercontent.com/xiaojianbu/markdownPicture/master/js%E4%B8%AD__proto__%E5%92%8Cprototype%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E5%85%B3%E7%B3%BB%EF%BC%9F/__proto__%E5%92%8Cprototype.jpg)

## 一道题目

来源： https://segmentfault.com/a/1190000003507782#

```js
let F = function() {}
Object.prototype.a = function() {}
Function.prototype.b = function() {}
let f = new F()
```

问：f 能取到 a,b 吗？原理是什么？

答：可以取到 a,不能取到 b。

原理：

### 原型

1.  在创建一个函数的时候，会自动为其创建一个原型对象，可以通过函数的**prototype**属性访问到；
2.  创建一个构造函数的实例对象，该实例对象内部将包含一个指针[[prototype]]，指向构造函数的原型对象。现在浏览器在每个对象上都支持一个属性\_\_proto\_\_,用于访问其构造函数的原型对象；

即：构造函数通过 prototype 属性访问原型对象。

实体对象通过[[prototype]]内部属性访问原型对象。

### 原型链

类 A 继承 B，B 继承 C...其实就是 A 的原型对象中有指针指向 B 的原型对象，而 B 的原型对象中有指针指向 C 的原型对象。

假设 a 是 A 的实例对象，则 a 的原型链为下图中紫色线条所示，橙色线条连接了构造函数和其原型对象。

![](https://raw.githubusercontent.com/xiaojianbu/markdownPicture/master/%E5%B0%8F%E8%A7%92%E5%BA%A6%E7%9C%8BJS%E5%8E%9F%E5%9E%8B%E9%93%BE/prototype-1.png)

### Function 和 Object

Object 是构造函数，既然是函数，那么就是 Function 的实例对象；Function 是构造函数，但 Function.prototype 是对象，既然是对象，那么就是 Object 的实例对象。

![](https://raw.githubusercontent.com/xiaojianbu/markdownPicture/master/%E5%B0%8F%E8%A7%92%E5%BA%A6%E7%9C%8BJS%E5%8E%9F%E5%9E%8B%E9%93%BE/prototype-2.png)

Object 作为构造函数，它有 prototype 属性指向 Object.prototype,作为实例对象，它有 Onject.\_\_proto\_\_指向 Function.prototype。

Function 是构造函数，它有 prototype 属性指向 Function.prototype,而 Function 是函数，从而也是 Function 的实例，所以它有 Function.\_\_proto\_\_指向 Function.prototype,从而 Function.\_\_proto\_\_ === Function.prototype。

Chrome 控制台验证如下图所示：

![](https://raw.githubusercontent.com/xiaojianbu/markdownPicture/master/%E5%B0%8F%E8%A7%92%E5%BA%A6%E7%9C%8BJS%E5%8E%9F%E5%9E%8B%E9%93%BE/prototype-3.png)

### 题目解析

解决原型链的问题最好的方法是画图，图如下：

![](https://raw.githubusercontent.com/xiaojianbu/markdownPicture/master/%E5%B0%8F%E8%A7%92%E5%BA%A6%E7%9C%8BJS%E5%8E%9F%E5%9E%8B%E9%93%BE/prototype-4.png)

f 的原型链为蓝色线所画，所以 f 可以访问到 a,不能访问到 b。

## 寄生组合式继承

一般只建议写这种，因为其它方式的继承会在一次实例中调用两次父类的构造函数或有其它缺点。

核心实现是：用一个 F 空的构造函数去取代执行了 Parent 这个构造函数。

```js
function Parent(name) {
  this.name = name
}
Parent.prototype.sayName = function() {
  console.log('parent name:', this.name)
}
function Child(name, parentName) {
  Parent.call(this, parentName)
  this.name = name
}
function create(proto) {
  function F() {}
  F.prototype = proto
  return new F()
}
Child.prototype = create(Parent.prototype)
Child.prototype.sayName = function() {
  console.log('child name:', this.name)
}
Child.prototype.constructor = Child

var parent = new Parent('father')
parent.sayName() // parent name: father

var child = new Child('son', 'father')
```

## 借用构造函数实现继承

```js
function Parent1() {
  this.name = 'parent1'
}
function Child1() {
  Parent1.call(this)
  this.type = 'child1'
}
```

缺点：Child1 无法继承 Parent1 的原型对象，并没有真正的实现继承（部分继承）

## 借用原型链实现继承

```js
function Parent2() {
  this.name = 'parent2'
  this.play = [1, 2, 3]
}
function Child2() {
  this.type = 'child2'
}
Child2.prototype = new Parent2()
```

缺点：原型对象的属性是共享的

## 组合式继承

```js
function Parent3() {
  this.name = 'parent3'
  this.play = [1, 2, 3]
}
function Child3() {
  Parent3.call(this)
  this.type = 'child3'
}
Child3.prototype = Object.create(Parent3.prototype)
Child3.prototype.constructor = Child3
```

## 实现一个 instanceOf

```js
function instanceOf(left, right) {
  let proto = left.__proto__
  let prototype = right.prototype
  while (true) {
    if (proto === null) return false
    if (proto === prototype) return true
    proto = proto.__proto__
  }
}
```
