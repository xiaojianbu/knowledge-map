# 云记账

诺诺云记账是诺诺网推出的面向中小微企业一款免费的在线财务软件。向企业提供新建账套、科目设置、录入初期、凭证录入、查看凭证、期末结转、查看账簿、查看报表、辅助核算、固定资产等功能。诺诺云代账是诺诺网推出的是一个在线代账运营管理平台。向代账机构提供一些列的管理服务以及代账功能。

技术栈：

- react@^16.13.1
- less@^3.11.3
- antd@^3.26.14
- react-router-dom@^5.1.2
- redux@^4.0.5
- redux-thunk@^2.3.0
- axios@^0.19.2
- qs@^6.9.3
- echarts@^4.5.0
- moment@^2.24.0

重构、表格结构组件、各平台数据适配

前端开发工具 NDK 基于 “搭建 -> 开发 -> 测试 -> 发布”的前端工作流，为前端开发者提供标准化、自动化的工具，用于减少重复及非必要的劳动。

了解背景 -> 了解方案 -> 深挖方案 -> 模拟场景

背景+自己的角色+技术栈+技术难点（或者解决了 xx 技术问题）+项目结果（业务结果：pv/uv，技术结果：优化效果等），
如果有沉淀（技术沉淀、框架沉淀等）就更好了，

XXX 项目出现 XXX 问题，我作为 XXX，负责其中的 XXX 部分，我通过 XXX 方式（或技术方案）成功解决了该问题，
使 XXX 提高了 XXX，XXX 增长了 XXX。

## 优化首屏加载速度

最近有客户反馈云代账在使用过程出现卡顿，操作不流畅。在运营同事的笔记本电脑也有出现类似的问题（使用 360 浏览器兼容模式，异步请求很慢，甚至长达 10 秒以上，但切换急速模式或使用其他浏览器未复现）。

问题原因尚在排查中，但在排查问题过程中发现云代账存在其他问题，我们来看页面的静态资源加载情况，见下图：

其中 common.704bdee.js 和 index.7c324c0.js 文件大小分别为 3.6 MB 和 1.2 MB。加载时间为 5.75 秒 和 2.94 秒，对比其他静态资源加载时间翻了 10 倍。所以，一开始访问页面时会出现白屏，要等一会才能看到内容。

从上图中可以看到样式文件加载尺寸都不大，只有几十 KB ，但前端代码库中打包的样式文件却有几百 KB，这是怎么回事呢？我们对比下请求头信息：

可以看到样式文件的 Response Headers 比 script 文件多了 gzip，也就是说，服务器对 style 文件启用的 gzip 压缩，将文件大小减少将近 80% ，如果能对 script 文件也启用 gzip ，那么 script 文件的加载时间也会降低很多，从而减少白屏的出现。

除此之外，script 文件大小达到 3.6 MB 是否正常呢？对比样式文件来看，这个 script 文件确实太大了，但可优化的空间并不多，像我们使用的 antd 组件，在全量压缩打包后文件体积也超过了 1 MB 。当然，后续还是会在前端打包这块做优化，尽可能的减小静态资源的文件体积。

到这里，我们已经有了 1 条优化建议：

启用 gzip 压缩。

那还有别的优化方式吗？我们刷新页面看看：

可以发现页面很快显示出来了，这是静态资源只加载了 184 B ，用时三四十毫秒，这是因为服务器返回了 304 状态，告诉浏览器使用缓存。除值之外，我们也可以看到有个别资源，是直接从内存获取，加载时间为 0 ms ，这是怎么做到的呢？对比 Response Headers 之后发现，这些从内存加载的请求没有 Cache-control: no-cache 参数，也就是说，让浏览器使用自身的缓存来提升加载速度：

所以第 2 条建议就是：

启用客户端缓存。

那么有人可能会担心，都使用客户端缓存了，那静态资源如果有更新怎么办呢？这个不必担心，现在前端资源都是按 [name].[contenthash].[ext] 的方式生成的，如果文件更新了，会生成一个新的文件名，只要保证引用资源的 html 页面能够更新，静态资源也就能更新。

综上所述，网站性能优化之服务器配置有两点：

1、启用静态资源的 gzip 压缩处理。

2、取消 no-cache 设置，启用客户端缓存，HTML 文件除外。

云财税首页中有部分内容使用了 4 张图片，页面效果如下：

这些图片可以压缩掉 60% 以上的大小。也就是说我们浪费了近 2/3 的流量。

拿到设计师给的图片后还要在尝试压缩图片。

除此之外，也可以考虑在服务器端或前端打包代码时引入图片压缩处理，待后续尝试。

通过 webpack-bundle-analyzer 来分包和异步加载

业务诉求
支持 SEO （搜索引擎优化）
页面访问速度提升
技术方案
支持 SEO （搜索引擎优化）
页面静态化
简单页面使用纯 HTML + CSS 实现
打包时生成初始的 HTML 内容（比如页面框架结构或初始内容）
基于 Node.js 的 SSR （待定，但在应用技术选型时需要考虑支持）
完善页面的 TDK 信息
正确使用语义化标签
补充图片 alt 属性
页面访问速度提升
开启服务器端 Gzip 配置，压缩静态资源文件体积
去除非 HTML 页面的静态资源的 cache-control: no-cache 配置，充分利用客户端缓存
减少页面加载时的请求数量。
减少 Cookie 中保存的信息或去除请求中的非必要 Cookie 信息
压缩图片体积（也可尝试更改图片格式，使用同等质量下体积最小的图片）
合并小图片为一张大图或将图片转为 base64 编码
延迟加载图片
移除冗余代码
封装公共组件（减少重复代码）
代码分割（将无变化或少变化的代码打包到一起，充分利用客户端缓存）
使用按需加载（一般情况下按照路由分割代码）
预渲染页面框架或骨架图

https://juejin.im/post/6844903613790175240

之前冬哥分享了网站优化方案总结中的页面访问速度提升的一些方案。我这边在分享几点，大致跟冬哥分享的差不多：

尽量减少 iframe 使用，它会阻塞主页面的渲染; 对所有资源压缩 JavaScript 、 CSS 、字体、图片等，甚至 html;
使用 link 标签的 rel 属性设置 prefetch（这段资源将会在未来某个导航或者功能要用到，但是本资源的下载顺序权重比较低，prefetch 通常用于加速下一次导航）、preload（preload 将会把资源得下载顺序权重提高，使得关键数据提前下载好，优化页面打开速度）
使用 CDN 加速，将通用的库从 vendor 进行抽离
Nginx 的 gzip 压缩
Vue 异步组件
服务端渲染 SSR
Webpack 开启 gzip 压缩
如果首屏为登录页，可以做成多入口
Service Worker 缓存文件处理

所有单个 JS、css、图片的静态文件大小尽量不要超过 1MB

图片：
前端代码中单个图片文件大小不能超过 800K 。如果超出，可以尝试下述方法处理：

1、和设计师确认图片是否已做优化（同一图片用不同格式文件大小会有很大差异，如：png 、 gif 、 jpeg 等）。

2、使用图片压缩服务比如 [TinyPNG](https://tinypng.com/) 压缩文件体积。

3、如果一定要使用超过规定大小的图片，可由业务方提出合适的理由，由该项目的 前端开发组长 和 前端架构师 进行评估。

css 、 js ：
1、对于前端代码中的 CSS 和 JS 文件，单个文件大小不能超过 1MB 。如果超出，可考虑将文件以按需加载方式拆分成多个文件。

2、前端组长 需要跟进项目部署服务器的配置，在不影响业务逻辑的情况下，打开静态服务器对 JS 和 CSS 文件的 GZip 压缩功能。

XXX 项目出现 XXX 问题，我作为 XXX，负责其中的 XXX 部分，我通过 XXX 方式（或技术方案）成功解决了该问题，
使 XXX 提高了 XXX，XXX 增长了 XXX。

优化了一个前端项目的首屏性能，降低了白屏时间，那么面试官对这个性能优化问题会进行深挖，来考察候选人的实际水平：

你的性能优化指标是怎么确定的？平均下来时间减短了多少？
你的性能是如何测试的？有两种主流的性能测试方法你是怎么选的？
你是根据哪些指标进行针对性优化的？
除了你说的这些优化方法还有没有想过通过 xx 来解决？
你的这个优化方法在实际操作中碰到过什么问题吗？有没有进一步做过测试？
我们假设这么一种情况，比如 xxxx，你会这么进行优化？

怎么从 3.5s 降低到 1.5s 的呢？这会“引导”面试官从这个问题进行话题切入，
此时你就带他来到了你所熟悉的领域。接下来就是你的 show time！
首先你可以准备好或者自己组织好 8 ～ 10 条优化内容，
可以从网络请求资源加载强弱缓存（http）、技术栈优化手段、
webpack 打包优化手段等等，甚至后面可以描述到所使用技术栈的源码实现等等，
其实这样就能讲述至少半小时以上了

首先得了解你性能优化的指标如何，接着需要了解你是这么测试的指标、再怎么进行针对性优化的，
再接着提出一些其它解决方案考察你对优化场景的知识储备和方案决策能力，最后再模拟一个其它的业务场景，
来考察你的技能迁移能力，看看是否是对某块领域有一定的了解，而不是只针对某个项目。
如果要真的在面试现场对答如流，那么一定是在某一块领域有一定知识储备的人，不是随随便便搞个项目就能蒙混过关的。

首屏加载文件大小（confidence 中的总结）

## 打印平台 CSS AST 转换应用

自定义报表

CSS AST 的简单转换

打印模板的功能，整体的做法是后端使用 freemaker，前端画好打印的模板，

这中间涉及到 css2Str Str2Css 的问题

## 自研的数据流管理方案 nuomi

用以解决路由缓存的问题

实现功能类似 dva、rematch、mirror

redux 原生写法实现功能需要写大量的 action、reducer 模板代码，对于复杂项目来说代码量 太多，且 action 文件和 reducer 文件等不停切换较为繁琐，开发体验较差。一般都会经过封装简化。

比如 dva 的实现方式，采用 model 的方式，并引入了 effects，把 state、effects、action、reducer 放在一个文件，简化了 action 和 reducer 的定义方式。

nuomi 原理 复合图层优化

## ant design 组件优化

像 form 表单，Form.create 包裹的组件在字段更新后，会重新渲染整个组件。在部分拥有大量表单项的页面时则会出现性能问题，一般使用拆表单去解决。

像 select 选项数据多的话，也会有卡顿，项目组沉淀了 superSelect 组件。

像 table 组件同理，superTable 组件，使用 hooks 做底部合计行

### 大数据表格

编辑器作为主力交互区域，需要面对大量的用户事件和用户输入，再加上多图联动，逻辑与交互极其复杂；
大规模数据展示造成页面卡顿，部分动画掉帧严重
经过优化之后，动画无掉帧现象

大数据表格编辑，逻辑与交互复杂
大规模数据展示造成页面卡顿，部分动画掉帧严重
性能经过优化之后，动画无掉帧现象，性能提升

遇到了什么问题：页面性能问题
在这过程中你是如何排查问题的：如何排查页面性能问题的
是如何定位问题的：通过火焰图发现某段长列表加载性能有问题
最终是如何解决这个问题的：通过虚拟列表来解决长列表问题

### antd select 大数据渲染

问题：数据量太大，一次性渲染节点过多，导致卡顿

方案：只渲染适合视口区域的部分数据，根据用户操作，再渲染一部分

视口容器 height

totalHeight,所有内容的高度（由单条内容高度\*总数量获得）

用 transform 代替滚动，用 div 模拟一个滚动条

支持上万条数据流畅滚动
和 antd Select 相同 api，使用简单
实现简单，可根据需求修改完善
支持 antd Form 中直接使用
实现方法
利用 antd Select dropdownRender 方法自定义下拉列表内容，只渲染可视区约几十条数据
计算列表滚动距离，滚动约可视区高度时重新渲染，减少渲染次数提高性能
代理原 antd Select onChange 等方法，实现相同 api 用法和回调参数返回

## 权限函数

rbac0 ～ 3、前端简单判断、后端按需返回。这

项目中的权限是 RCB0 用户 角色 后端返回权限码，前端根据不同的权限码判断是否加载页面和页面中的各个操作

如何设计权限系统，如何维护和定义、表的数据结构是怎样的

我们的项目是 rbac1 类型的权限系统。展示是树形结构，但权限是扁平化的，只需要勾选权限，可以达到灵活修改权限。比如角色 includes 权限[1, 2, 3]，某操作需要权限 1，只需要判断 1 是否在角色所有的权限数组里面即可

## Typescript

TS 在项目中的应用

针对挂载在 Window 上的全局方法，利用 Typescript 和 JSDoc 为项目编写公共方法的 global.d.ts，可以不用到处查配置 (默认 js 的只能支持直接导入的代码提示，全局函数、变量或者有些比较复杂的好像就不行)，提高开发过程中编码效率。

## code review

启动原因是：一定时间内出现线上问题的次数增多

1. 功能遗漏
2. 校验问题，验证不全
3. 代码修改，没有用的代码没有及时删除

推动团队的开发效率和质量，定时开展项目 code review

1. 提取公共变量，公共方法
2. 代码要加好注释
3. 没有用的代码及时删除、定义了但没有用到的变量也要及时删除

代码评审不必责备求全，可以逐步推进。
第一步要解决的是代码风格问题，统一的代码风格评审起来才能事半功倍。
第二步是代码规范问题，Java 的话按阿里的规约取舍一下就好。规范执行到位，bug 能少一大半。
第三步是代码结构问题，编程最大的问题不是写错了代码，而是代码没写对地方。这个问题包括但不限于：代码冗余、过大的类和方法、方法有太多的参数、项目结构混乱或根本没有结构……说白了就是没有任何封装或者错误的封装。

以上做好了，代码基本也就没啥毛病了

## UV 统计 SDK

需求分为两种：

1. 页面初始打开时统计一次，只传递 appId(页面打开加载 SDK 后自动执行)
2. 用户登录后统计一次，传递 appID、userId

通过 script 标签异步引入到 html 文件

引入文件后会添加全局方法： nuoUVTrack

需定义每个应用的 id，具体 id 命名需和自动化运维平台命名相同

```diff

+   <script>window.nuoAppTrackId = 'nuonuo-cloud-jz';</script>
+   <script src="//data.jss.com.cn/statisticsvu/nuoUVTrack.min.js"></script>

```

一般都会在登录成功跳转到首页，首页有相应接口查询用户信息，可在查询用户信息接口返回数据时拿到 userName,即可发送请求。

userId 当前登录用户唯一识别代码，采用 userName

```diff
+   try {
+       window.nuoUVTrack && window.nuoUVTrack({userId: data.userName})
+   } catch (err) {
+       console.log('track error': err)
+   }
```

## ie 下刷新页面图标丢失的问题

排查和解决问题：经排查记账代账 ie 下刷新页面图标消失，初步判定是服务器配置问题，经询问近期配置未做更改，排查代码问题和浏览器表现，发现 ie 刷新后多加载了 2 个字体文件，排查响应头信息、请求头信息和论坛搜索等，判断是增加了 no-store 引起的。修改 nginx 配置后问题解决。

## 模块目录结构

```json
|-- components    // ui 组件
|-- effects       // effects 独立管理
|-- services      // 异步请求 services
|-- constant      // 模块常量
|-- utils         // 模块工具函数
|-- index.jsx     // 模块入口
```

### index.jsx

文件导出一个对象，state 定义初始状态；reducers 控制状态的更新；effects 管理业务逻辑；onInit 业务初始化。可以通过给 effects 中的方法添加 \$ 前缀可以做到程序 auto loading 功能。

```js
export default {
  state: {
    dataSource: []
  },
  reducers: {
    updateState: (state, { payload }) => ({ ...state, ...payload })
  },
  effects,
  onInit() {
    this.store.dispatch({ type: 'init })
  }
}
```

### effects

```js
export default {
  setState(data) {
    this.dispatch({
      type: 'updateState',
      payload: data
    })
  }

  async init() {
    await services.init()
  }
}
```

### components

react hooks

```jsx
import React, { useEffect } from 'react'

const Layout = () => {
  const refreshPage = (e) => {
    const { data } = e
    if (typeof data === 'string') {
      const { type } = JSON.parse(data)
      if (type === 'reload') {
        window.location.reload()
      }
    }
  }
  useEffect(() => {
    window.addEventListener('message', refreshPage, false)
    return () => {
      window.removeEventListener('message', refreshPage, false)
    }
  })

  return <div>Layout</div>
}
```

```less
.content {
  position: absolute;
  top: 0px;
  bottom: 0px;
  right: 0px;
  left: 0px;
  background-color: #e5e6ea;
  overflow: hidden;
}
```

```jsx
// Layout
import React from 'react';
import { Route, Router } from 'nuomi';
import routeList from '../router';
import './style.less';

const Layout = () => {
  const routes = routeList

  return (
    <div styleName="content">
      <Router hashPrefix="!">
        {routes.map(({ path, ...rest }) => (
          <Route key={path} path={path} {...rest}>
        ))}
      </Router>
    </div>
  )
}
```

## 对 B 和 C 端业务对理解

简单来说，B 端 ui 要求低、架构复杂；C 端 ui 要求高、架构简单。

### tob 业务架构设计、技术选型

先出结构图、流程图，再给出表结构设计，确定了方案，组件、模块划分。技术选型一般就是三大框架+配套的标准 ui 了，如 vue 与 ele-ui，react 与 antd，加上状态管理、路由等。如果复杂的混杂多项目多系统，使用微前端，spa 或者 iframe 两种取其一，如果没有历史包袱可选 spa、如果有历史包袱使用 iframe 嵌入，但需要和其他前端进行对协议
