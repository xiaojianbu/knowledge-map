# 云记账

诺诺云记账是诺诺网推出的面向中小微企业一款免费的在线财务软件。向企业提供新建账套、科目设置、录入初期、凭证录入、查看凭证、期末结转、查看账簿、查看报表、辅助核算、固定资产等功能。诺诺云代账是诺诺网推出的是一个在线代账运营管理平台。向代账机构提供一些列的管理服务以及代账功能。

技术栈：

- react@^16.13.1
- less@^3.11.3
- antd@^3.26.14
- react-router-dom@^5.1.2
- redux@^4.0.5
- redux-thunk@^2.3.0
- axios@^0.19.2
- qs@^6.9.3
- echarts@^4.5.0
- moment@^2.24.0

重构、表格结构组件、各平台数据适配

前端开发工具 NDK 基于 “搭建 -> 开发 -> 测试 -> 发布”的前端工作流，为前端开发者提供标准化、自动化的工具，用于减少重复及非必要的劳动。

了解背景 -> 了解方案 -> 深挖方案 -> 模拟场景

背景+自己的角色+技术栈+技术难点（或者解决了 xx 技术问题）+项目结果（业务结果：pv/uv，技术结果：优化效果等），
如果有沉淀（技术沉淀、框架沉淀等）就更好了，

XXX 项目出现 XXX 问题，我作为 XXX，负责其中的 XXX 部分，我通过 XXX 方式（或技术方案）成功解决了该问题，
使 XXX 提高了 XXX，XXX 增长了 XXX。

## 优化首屏加载速度

有客户反馈云记账首页打开慢出现白屏，后面去做问题排查发现页面的静态资源加载中，其中 common.704bdee.js 和 index.7c324c0.js 文件大小分别为 3.6 MB 和 1.2 MB。加载时间为 5.75 秒 和 2.94 秒，对比其他静态资源加载时间翻了 10 倍。所以，一开始访问页面时会出现白屏，要等一会才能看到内容。

观察发现服务器只对 style 文件启用的 gzip 压缩，将文件大小减少将近 80%，但是没有对 JS 文件启用 gzip 压缩，后面联系运维修改了部署服务器的配置，打开静态服务器对 JS 文件的 GZip 压缩功能，提高了首屏渲染时间。

同时首页有部分图片没有进行压缩，和设计师确认图片是否已做优化，后面拿到设计师给的图片后压缩图片（TinyPNG）

其他的优化像服务器缓存、代码分割、按需加载原先都有处理好。

其他的优化办法：

- 减少页面加载时的请求数量
- 减少 Cookie 中保存的信息或去除请求中的非必要 Cookie 信息
- 压缩图片体积
- 小图片转为 base64 编码
- 移除冗余代码
- 使用 CDN 加速，将通用的库从 vendor 进行抽离
- 所有单个 JS、css、图片的静态文件大小尽量不要超过 1MB

优化了一个前端项目的首屏性能，降低了白屏时间，那么面试官对这个性能优化问题会进行深挖，来考察候选人的实际水平：

你的性能优化指标是怎么确定的？平均下来时间减短了多少？
查看资源加载时间，时间缩小为十分之一

## 浏览器打印方案调研

window.print

- 不能精确分页，有出现打出半行字的风险；
- 改变纸型后打印出的格式和页面显示的格式相差太大；
- 页眉页脚也需要从菜单中去设置，等等。

使用 print css

浏览器差异性较大

导出 pdf 文件的打印

服务端返回 pdf 文件，需要服务端（freemarker）配合，前端画好模板

## 打印平台 CSS AST 转换应用

打印平台、自定义报表需要存储用户设置的样式数据，其中涉及到 JS 对象和 JSON 字符串相互转换的问题，页面用一个 JS 对象来保存样式信息，当传递给后端时，对象中的数据进行一些转换（就驼峰转下划线），转换为 CSS 字符串。前端收到后端传递回来的 CSS 字符串时，也要转换为 JS 对象来进行后续处理使用，可以利用 CSS 的抽象语法树来处理，利用 rework 解析器

```json
{
  "type": "stylesheet",
  "stylesheet": {
    "rules": [
      {
        "type": "rule",
        "selectors": ["#main"],
        "declarations": [
          {
            "type": "declaration",
            "property": "border",
            "value": "1px solid black",
            "position": {
              "start": {
                "line": 2,
                "column": 5
              },
              "end": {
                "line": 2,
                "column": 28
              }
            }
          }
        ],
        "position": {
          "start": {
            "line": 1,
            "column": 1
          },
          "end": {
            "line": 3,
            "column": 2
          }
        }
      }
    ],
    "parsingErrors": []
  }
}
```

只关注 selectors 和 declarations，可以看出 selectors 即为 CSS 选择器的值， declarations 中的每个对象的 property 和 value 即为 CSS 的属性(property)和值(value)。

## 自研的数据流管理方案 nuomi

### router 自研

路由缓存

功能需求：

路由切换到已经打开的模块时保留上次打开时页面的历史数据和状态

Vue 实现: Keep-alive

为什么要重新开发路由？

1. React-router 路由切换会卸载对应组件，不支持路由切换时缓存状态
2. 社区路由缓存实现方案不成熟
3. 参考原先的 Nui 路由系统，封装为组件即可

路由缓存实现方案

1. Store 缓存模块数据，路由返回时恢复状态
2. 路由修改时不删除组件，只是隐藏（display：none）(ps:react-router issue 推荐)
3. 缓存组件并渲染到 Route 外部（社区有 react-keep-alive）

项目组采用的是第二种，使用组件包裹 layout 的最内层，原理就是劫持了 children。 同时为了避免 display：none 切换引起的重绘问题，在组件外部包裹一层设置为 absolute，脱离普通文档流。

### Redux 封装简化

为什么不用原生 Redux

redux 原生写法实现功能需要写大量的 action、reducer 模板代码，对于复杂项目来说代码量太多，且 action 文件和 reducer 文件等不停切换较为繁琐，开发体验较差。一般都会经过封装简化。Reducer 中大量 switch case 判断 action type；还要考虑异步处理：Redux-thunk，Redux-saga

简化过程是：

- 增加 effects 模块，专用于处理异步请求等副作用
  Async await 处理异步流程
  组件中 dispatch 可触发 effects
  Effects 中触发 action，reducer 更新 store
- Reducer 和 action 合并定义，减少 action 数量，简化代码

实现功能类似 dva、rematch、mirror

比如 dva 的实现方式，采用 model 的方式，并引入了 effects，把 state、effects、action、reducer 放在一个文件，简化了 action 和 reducer 的定义方式。

为什么不是 DvaJS

- Dva Router 不支持缓存
- Dva model
- 复杂的 saga

### Nuomi 原理

- 参考思想：Dva
- api 使用和 redux 原生相同，但更简洁
- Redux 关联路由模块，全局单一 store
- 调用模块内 effects、actions 不需要使用命名空间
- Async await 简洁异步处理
- 支持对 effects 异步函数自动添加 loading（类似 dva loading 插件）

- 全局 store 对象，加载各模块 model
  - 集中加载 model，按 namespace 区分
  - 封装处理 action 和 reducer，简化代码
- 扩展 connect 方法
  - 扩展 dispatch，支持 dispatch 触发 effects 方法

## ant design 组件优化

像 form 表单，Form.create 包裹的组件在字段更新后，会重新渲染整个组件。在部分拥有大量表单项的页面时则会出现性能问题，一般使用拆表单去解决。

像 select 选项数据多的话，也会有卡顿，项目组沉淀了 superSelect 组件。

像 table 组件同理，superTable 组件，使用 hooks 做底部合计行

### form 表单

员工管理页面，30+的表单字段

通过 React Developer Tools 的 Profiler 观察

社区给的方案是拆分表单

### 大数据表格

当数据量过大，页面一次性渲染，造成页面卡顿，部分动画掉帧严重，甚至造成浏览器的奔溃现象。

解决方法一般是：分页展示，虚拟滚动，展示一部分用户可以看到的数据。

对于不同的业务和产品经理商量是否可以使用分页展示，不行的再使用虚拟滚动的方式来处理。

计算表格容器高度，根据行高计算得出表格显示数量，用 transform 代替滚动，滚动的时候计算出滚动高度，得出显示的 index，根据 index 和表格显示数量切割显示表格数据

### antd select 大数据渲染

问题：数据量太大，一次性渲染节点过多，导致卡顿

方案：只渲染适合视口区域的部分数据，根据用户操作，再渲染一部分

视口容器 height

totalHeight,所有内容的高度（由单条内容高度\*总数量获得）

用 transform 代替滚动，用 div 模拟一个滚动条

支持上万条数据流畅滚动和 antd Select 相同 api，使用简单

实现方法

利用 antd Select dropdownRender 方法自定义下拉列表内容，只渲染可视区约几十条数据计算列表滚动距离，滚动约可视区高度时重新渲染，减少渲染次数提高性能

代理原 antd Select onChange 等方法，实现相同 api 用法和回调参数返回

## 权限函数

rbac0 ～ 3、前端简单判断、后端按需返回。这

项目中的权限是 RCB0 用户 角色 后端返回权限码，前端根据不同的权限码判断是否加载页面和页面中的各个操作

如何设计权限系统，如何维护和定义、表的数据结构是怎样的

我们的项目是 rbac1 类型的权限系统。展示是树形结构，但权限是扁平化的，只需要勾选权限，可以达到灵活修改权限。比如角色 includes 权限[1, 2, 3]，某操作需要权限 1，只需要判断 1 是否在角色所有的权限数组里面即可

## Typescript

TS 在项目中的应用

针对挂载在 Window 上的全局方法，利用 Typescript 和 JSDoc 为项目编写公共方法的 global.d.ts，可以不用到处查配置 (默认 js 的只能支持直接导入的代码提示，全局函数、变量或者有些比较复杂的好像就不行)，提高开发过程中编码效率。

## code review

启动原因是：一定时间内出现线上问题的次数增多

1. 功能遗漏
2. 校验问题，验证不全
3. 代码修改，没有用的代码没有及时删除

推动团队的开发效率和质量，定时开展项目 code review

1. 提取公共变量，公共方法
2. 代码要加好注释
3. 没有用的代码及时删除、定义了但没有用到的变量也要及时删除

## UV 统计 SDK

需求分为两种：

1. 页面初始打开时统计一次，只传递 appId(页面打开加载 SDK 后自动执行)
2. 用户登录后统计一次，传递 appID、userId

通过 script 标签异步引入到 html 文件

引入文件后会添加全局方法： nuoUVTrack

需定义每个应用的 id，具体 id 命名需和自动化运维平台命名相同

```diff

+   <script>window.nuoAppTrackId = 'nuonuo-cloud-jz';</script>
+   <script src="//data.jss.com.cn/statisticsvu/nuoUVTrack.min.js"></script>

```

一般都会在登录成功跳转到首页，首页有相应接口查询用户信息，可在查询用户信息接口返回数据时拿到 userName,即可发送请求。

userId 当前登录用户唯一识别代码，采用 userName

```diff
+   try {
+       window.nuoUVTrack && window.nuoUVTrack({userId: data.userName})
+   } catch (err) {
+       console.log('track error': err)
+   }
```

## ie 下刷新页面图标丢失的问题

排查和解决问题：经排查记账代账 ie 下刷新页面图标消失，初步判定是服务器配置问题，经询问近期配置未做更改，排查代码问题和浏览器表现，发现 ie 刷新后多加载了 2 个字体文件，排查响应头信息、请求头信息和论坛搜索等，判断是增加了 no-store 引起的。修改 nginx 配置后问题解决。

## 模块目录结构

```json
|-- components    // ui 组件
|-- effects       // effects 独立管理
|-- services      // 异步请求 services
|-- constant      // 模块常量
|-- utils         // 模块工具函数
|-- index.jsx     // 模块入口
```

### index.jsx

文件导出一个对象，state 定义初始状态；reducers 控制状态的更新；effects 管理业务逻辑；onInit 业务初始化。可以通过给 effects 中的方法添加 \$ 前缀可以做到程序 auto loading 功能。

```js
export default {
  state: {
    dataSource: []
  },
  reducers: {
    updateState: (state, { payload }) => ({ ...state, ...payload })
  },
  effects,
  onInit() {
    this.store.dispatch({ type: 'init })
  }
}
```

### effects

```js
export default {
  setState(data) {
    this.dispatch({
      type: 'updateState',
      payload: data
    })
  }

  async init() {
    await services.init()
  }
}
```

### components

react hooks

```jsx
import React, { useEffect } from 'react'

const Layout = () => {
  const refreshPage = (e) => {
    const { data } = e
    if (typeof data === 'string') {
      const { type } = JSON.parse(data)
      if (type === 'reload') {
        window.location.reload()
      }
    }
  }
  useEffect(() => {
    window.addEventListener('message', refreshPage, false)
    return () => {
      window.removeEventListener('message', refreshPage, false)
    }
  })

  return <div>Layout</div>
}
```

```less
.content {
  position: absolute;
  top: 0px;
  bottom: 0px;
  right: 0px;
  left: 0px;
  background-color: #e5e6ea;
  overflow: hidden;
}
```

```jsx
// Layout
import React from 'react';
import { Route, Router } from 'nuomi';
import routeList from '../router';
import './style.less';

const Layout = () => {
  const routes = routeList

  return (
    <div styleName="content">
      <Router hashPrefix="!">
        {routes.map(({ path, ...rest }) => (
          <Route key={path} path={path} {...rest}>
        ))}
      </Router>
    </div>
  )
}
```

## 对 B 和 C 端业务对理解

简单来说，B 端 ui 要求低、架构复杂；C 端 ui 要求高、架构简单。

### tob 业务架构设计、技术选型

先出结构图、流程图，再给出表结构设计，确定了方案，组件、模块划分。

技术选型一般就是三大框架+配套的标准 ui 了，如 vue 与 ele-ui，react 与 antd，加上状态管理、路由等。主要还是看团队的意见。
