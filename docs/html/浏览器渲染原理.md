# 浏览器渲染原理

## 文章来源

[浏览器的渲染原理简介](https://coolshell.cn/articles/9666.html)

## 浏览器工作大流程

![浏览器渲染原理](https://raw.githubusercontent.com/xiaojianbu/markdownPicture/master/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/Render-Process.jpg)

从上图中可知:

1. 浏览器会解析三个东西

   - HTML，生成 DOM 树
   - CSS，生成 CSS 规则树
   - JS，主要是通过 DOM API 和 CSSDOM API 来操作 DOM tree 和 CSS Rule Tree

2. 解析完成后，浏览器引擎会通过 DOM tree 和 CSS Rule tree 来构造 Rendering tree.

   - Rendering tree 渲染树并不等同于 DOM 树，因为一些像 Header 或 display:none 的东西没有在渲染树中；
   - CSS 的 Rule tree 主要是为了完成匹配并把 CSS Rule 附加上 Rendering tree 上的每个 element。也就是 DOM 结点。也就是所谓的 Frame。
   - 然后，计算每个 Frame（也就是每个 element）的位置，这又叫 layout 和 reflow 过程。

3. 最后通过调用操作系统的 GUI 的 API 绘制。

### DOM 解析

HTML 的 DOM tree 解析如下：

```html
<html>
<html>
<head>
    <title>Web page parsing</title>
</head>
<body>
    <div>
        <h1>Web page parsing</h1>
        <p>This is an example Web page.</p>
    </div>
</body>
</html>
```

上段 HTML 解析为下图所示：

![DOM树-1](https://raw.githubusercontent.com/xiaojianbu/markdownPicture/master/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/DOM-Tree-01.jpg)

下面是另一个有 SVG 标签的情况：

![DOM树-2](https://raw.githubusercontent.com/xiaojianbu/markdownPicture/master/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/DOM-Tree-02.jpg)

### CSS 解析

假设有下面的 HTML 文档：

```html
<doc>
<title>A few quotes</title>
<para>
  Franklin said that <quote>"A penny saved is a penny earned."</quote>
</para>
<para>
  FDR said <quote>"We have nothing to fear but <span>fear itself.</span>"</quote>
</para>
</doc>
```

CSS 文档如下：

```css
/* rule 1 */
doc {
  display: block;
  text-indent: 1em;
}
/* rule 2 */
title {
  display: block;
  font-size: 3em;
}
/* rule 3 */
para {
  display: block;
}
/* rule 4 */
[class='emph'] {
  font-style: italic;
}
```

CSS tree 如下所示：

![CSS树](https://raw.githubusercontent.com/xiaojianbu/markdownPicture/master/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/CSS-Rule-Tree-Example.jpg)

### 渲染

渲染的流程基本上如下（黄色的四个步骤）：

- 计算 CSS 样式
- 构建 Render Tree
- Layout – 定位坐标和大小，是否换行，各种 position, overflow, z-index 属性 ……
- 正式开画

![Render-Process-Skipping](https://raw.githubusercontent.com/xiaojianbu/markdownPicture/master/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/Render-Process-Skipping.jpg)

注意：上图流程中有很多连接线，这表示了 Javascript 动态修改了 DOM 属性或是 CSS 属会导致重新 Layout，有些改变不会，就是那些指到天上的箭头，比如，修改后的 CSS rule 没有被匹配到，等。

#### Reflow

意味着元件的几何尺寸变了，我们需要重新验证并计算 Render Tree。是 Render Tree 的一部分或全部发生了变化。这就是 Reflow，或是 Layout。（HTML 使用的是 flow based layout，也就是流式布局，所以，如果某元件的几何尺寸发生了变化，需要重新布局，也就叫 reflow）reflow 会从<html>这个 root frame 开始递归往下，依次计算所有的结点几何尺寸和位置，在 reflow 过程中，可能会增加一些 frame，比如一个文本字符串必需被包装起来。

Reflow 的成本比 Repaint 的成本高得多的多。DOM Tree 里的每个结点都会有 reflow 方法，一个结点的 reflow 很有可能导致子结点，甚至父点以及同级结点的 reflow。

#### Repaint

屏幕的一部分要重画，比如某个 CSS 的背景色变了。但是元素的几何尺寸没有变。

所以，下面这些动作有很大可能会是成本比较高的。

- 当你增加、删除、修改 DOM 结点时，会导致 Reflow 或 Repaint
- 当你移动 DOM 的位置，或是搞个动画的时候。
- 当你修改 CSS 样式的时候。
- 当你 Resize 窗口的时候（移动端没有这个问题），或是滚动的时候。
- 当你修改网页的默认字体时。

注：display:none 会触发 reflow，而 visibility:hidden 只会触发 repaint，因为没有发现位置变化。

一般来说，浏览器会把这样的操作积攒一批，然后做一次 reflow，这又叫异步 reflow 或增量异步 reflow。

#### reflow/repaint

1. 不要一条一条地修改 DOM 的样式。与其这样，还不如预先定义好 css 的 class，然后修改 DOM 的 className。
2. 不要把 DOM 结点的属性值放在一个循环里当成循环里的变量。
3. 尽可能的修改层级比较低的 DOM。
