# 浏览器渲染原理

## 文章来源

[浏览器的渲染原理简介](https://coolshell.cn/articles/9666.html)

## 浏览器工作大流程

![浏览器渲染原理](https://raw.githubusercontent.com/xiaojianbu/markdownPicture/master/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/Render-Process.jpg)

从上图中可知:

1. 浏览器会解析三个东西

   - HTML，生成 DOM 树
   - CSS，生成 CSS 规则树
   - JS，主要是通过 DOM API 和 CSSDOM API 来操作 DOM tree 和 CSS Rule Tree

2. 解析完成后，浏览器引擎会通过 DOM tree 和 CSS Rule tree 来构造 Rendering tree.

   - Rendering tree 渲染树并不等同于 DOM 树，因为一些像 Header 或 display:none 的东西没有在渲染树中；
   - CSS 的 Rule tree 主要是为了完成匹配并把 CSS Rule 附加上 Rendering tree 上的每个 element。也就是 DOM 结点。也就是所谓的 Frame。
   - 然后，计算每个 Frame（也就是每个 element）的位置，这又叫 layout 和 reflow 过程。

3. 最后通过调用操作系统的 GUI 的 API 绘制。

### 注意

1. css 加载不会阻塞 DOM 树的解析
2. css 加载会阻塞 DOM 树的渲染
3. css 加载会阻塞后面 js 语句的执行

提高 css 加载速度，比如可以使用以下几种方法:

1. 使用 CDN(因为 CDN 会根据你的网络状况，替你挑选最近的一个具有缓存内容的节点为你提供资源，因此可以减少加载时间)
2. 对 css 进行压缩(可以用很多打包工具，比如 webpack,gulp 等，也可以通过开启 gzip 压缩)
3. 合理的使用缓存(设置 cache-control,expires,以及 E-tag 都是不错的，不过要注意一个问题，就是文件更新后，你要避免缓存而带来的影响。其中一个解决防范是在文件名字后面加一个版本号)
4. 减少 http 请求数，将多个 css 文件合并，或者是干脆直接写成内联样式(内联样式的一个缺点就是不能缓存)

### DOM 解析

HTML 的 DOM tree 解析如下：

```html
<html>
  <html>
    <head>
      <title>Web page parsing</title>
    </head>
    <body>
      <div>
        <h1>Web page parsing</h1>
        <p>This is an example Web page.</p>
      </div>
    </body>
  </html>
</html>
```

上段 HTML 解析为下图所示：

![DOM树-1](https://raw.githubusercontent.com/xiaojianbu/markdownPicture/master/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/DOM-Tree-01.jpg)

下面是另一个有 SVG 标签的情况：

![DOM树-2](https://raw.githubusercontent.com/xiaojianbu/markdownPicture/master/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/DOM-Tree-02.jpg)

### CSS 解析

假设有下面的 HTML 文档：

```html
<doc>
  <title>A few quotes</title>
  <para>
    Franklin said that <quote>"A penny saved is a penny earned."</quote>
  </para>
  <para>
    FDR said
    <quote>"We have nothing to fear but <span>fear itself.</span>"</quote>
  </para>
</doc>
```

CSS 文档如下：

```css
/* rule 1 */
doc {
  display: block;
  text-indent: 1em;
}
/* rule 2 */
title {
  display: block;
  font-size: 3em;
}
/* rule 3 */
para {
  display: block;
}
/* rule 4 */
[class='emph'] {
  font-style: italic;
}
```

CSS tree 如下所示：

![CSS树](https://raw.githubusercontent.com/xiaojianbu/markdownPicture/master/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/CSS-Rule-Tree-Example.jpg)

### 渲染

渲染的流程基本上如下（黄色的四个步骤）：

- 计算 CSS 样式
- 构建 Render Tree
- Layout – 定位坐标和大小，是否换行，各种 position, overflow, z-index 属性 ……
- 正式开画

![Render-Process-Skipping](https://raw.githubusercontent.com/xiaojianbu/markdownPicture/master/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/Render-Process-Skipping.jpg)

注意：上图流程中有很多连接线，这表示了 Javascript 动态修改了 DOM 属性或是 CSS 属会导致重新 Layout，有些改变不会，就是那些指到天上的箭头，比如，修改后的 CSS rule 没有被匹配到，等。

#### Reflow

意味着元件的几何尺寸变了，我们需要重新验证并计算 Render Tree。是 Render Tree 的一部分或全部发生了变化。这就是 Reflow，或是 Layout。（HTML 使用的是 flow based layout，也就是流式布局，所以，如果某元件的几何尺寸发生了变化，需要重新布局，也就叫 reflow）reflow 会从<html>这个 root frame 开始递归往下，依次计算所有的结点几何尺寸和位置，在 reflow 过程中，可能会增加一些 frame，比如一个文本字符串必需被包装起来。

Reflow 的成本比 Repaint 的成本高得多的多。DOM Tree 里的每个结点都会有 reflow 方法，一个结点的 reflow 很有可能导致子结点，甚至父点以及同级结点的 reflow。

#### Repaint

屏幕的一部分要重画，比如某个 CSS 的背景色变了。但是元素的几何尺寸没有变。

所以，下面这些动作有很大可能会是成本比较高的。

- 当你增加、删除、修改 DOM 结点时，会导致 Reflow 或 Repaint
- 当你移动 DOM 的位置，或是搞个动画的时候。
- 当你修改 CSS 样式的时候。
- 当你 Resize 窗口的时候（移动端没有这个问题），或是滚动的时候。
- 当你修改网页的默认字体时。

注：display:none 会触发 reflow，而 visibility:hidden 只会触发 repaint，因为没有发现位置变化。

一般来说，浏览器会把这样的操作积攒一批，然后做一次 reflow，这又叫异步 reflow 或增量异步 reflow。

#### reflow/repaint

1. 不要一条一条地修改 DOM 的样式。与其这样，还不如预先定义好 css 的 class，然后修改 DOM 的 className。
2. 不要把 DOM 结点的属性值放在一个循环里当成循环里的变量。
3. 尽可能的修改层级比较低的 DOM。

### JS 资源

阻塞浏览器的解析，也就是说发现一个外链脚本时，需等待脚本下载完成并执行后才会继续解析 HTML

普通的脚本会阻塞浏览器解析，加上 defer 或 async 属性，脚本就变成异步，可等到解析完毕再执行

两者都不会阻止 document 的解析

defer 会在 DOMContentLoaded 前依次执行

async 则是下载完立即执行，不一定是在 DOMContentLoaded 前

async 因为顺序无关

DOMContentLoaded: 浏览器已经完全加载了 HTML，DOM 树已经构建完毕，但是像是 img 和样式表等外部资源可能并没有下载完毕。

onload: 浏览器已经加载了所有的资源（图像，样式表等）

## CSS 加载会造成阻塞么

没有 js 的理想情况下，html 与 css 会并行解析，分别生成 DOM 与 CSSOM，然后合并成 Render Tree，进入 Rendering Pipeline；但如果有 js，css 加载会阻塞后面 js 语句的执行，而（同步）js 脚本执行会阻塞其后的 DOM 解析（所以通常会把 css 放在头部，js 放在 body 尾）

1. css 加载不会阻塞 DOM 树的解析
2. css 加载会阻塞 DOM 树的渲染
3. css 加载会阻塞后面 js 语句的执行
